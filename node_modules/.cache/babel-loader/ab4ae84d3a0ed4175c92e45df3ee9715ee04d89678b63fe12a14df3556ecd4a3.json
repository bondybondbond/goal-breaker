{"ast":null,"code":"import { gridToPosition, calculateChildPosition } from './gridHelpers';\n\n/**\r\n * Convert goals structure to Mermaid diagram format\r\n * @param mainGoal - The main goal text (can be empty if using goals array)\r\n * @param goals - Array of goal objects\r\n * @returns Mermaid diagram string\r\n */\nexport const exportToMermaid = (mainGoal, goals) => {\n  if (goals.length === 0) return '';\n  const lines = ['graph TD'];\n\n  // Generate unique node IDs (A, B, C, etc.)\n  const getNodeId = index => {\n    return String.fromCharCode(65 + index); // A, B, C, D...\n  };\n\n  // Sort goals by level and creation order for consistent output\n  const sortedGoals = [...goals].sort((a, b) => {\n    if (a.level !== b.level) return a.level - b.level;\n    return a.id - b.id;\n  });\n\n  // Create mapping of goal.id to node ID\n  const goalToNodeId = new Map();\n  sortedGoals.forEach((goal, index) => {\n    goalToNodeId.set(goal.id, getNodeId(index));\n  });\n\n  // Add goal nodes\n  sortedGoals.forEach(goal => {\n    const nodeId = goalToNodeId.get(goal.id);\n    const escapedText = goal.text.replace(/\"/g, '\\\"'); // Escape quotes\n    const displayText = goal.text || (goal.level === 0 ? 'Main Goal' : 'Untitled Task');\n    const finalText = goal.completed ? `✅ ${escapedText || displayText}` : escapedText || displayText;\n    lines.push(`    ${nodeId}[\"${finalText}\"]`);\n  });\n\n  // Add connections\n  sortedGoals.forEach(goal => {\n    const childNodeId = goalToNodeId.get(goal.id);\n    if (goal.parentId !== null) {\n      // Connect to parent goal\n      const parentNodeId = goalToNodeId.get(goal.parentId);\n      if (parentNodeId) {\n        lines.push(`    ${parentNodeId} --> ${childNodeId}`);\n      }\n    }\n  });\n  return lines.join('\\n');\n};\n;\n\n/**\r\n * Copy text to clipboard with fallback for older browsers\r\n * @param text - Text to copy\r\n * @returns Promise<boolean> - Success status\r\n */\nexport const copyToClipboard = async text => {\n  try {\n    if (navigator.clipboard && window.isSecureContext) {\n      await navigator.clipboard.writeText(text);\n      return true;\n    } else {\n      // Fallback for older browsers\n      const textArea = document.createElement('textarea');\n      textArea.value = text;\n      textArea.style.position = 'fixed';\n      textArea.style.left = '-999999px';\n      textArea.style.top = '-999999px';\n      document.body.appendChild(textArea);\n      textArea.focus();\n      textArea.select();\n      const result = document.execCommand('copy');\n      document.body.removeChild(textArea);\n      return result;\n    }\n  } catch (error) {\n    console.error('Failed to copy to clipboard:', error);\n    return false;\n  }\n};\n\n/**\r\n * Parse Mermaid diagram format and convert to goals structure\r\n * @param mermaidCode - The Mermaid diagram string\r\n * @returns Object with success status and either goals array or error message\r\n */\nexport const importFromMermaid = mermaidCode => {\n  try {\n    const lines = mermaidCode.trim().split('\\n');\n\n    // Validate basic format\n    if (lines.length === 0 || !lines[0].trim().startsWith('graph TD')) {\n      return {\n        success: false,\n        error: 'Invalid format: Must start with \"graph TD\"'\n      };\n    }\n    const nodes = new Map();\n    const connections = new Map(); // parent -> children\n    const nodeOrder = [];\n\n    // Parse nodes and connections\n    for (let i = 1; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (!line) continue;\n\n      // Parse node definitions: A[\"✅ Task text\"] or A[\"📝 Task text\"] or A[\"Task text\"]\n      const nodeMatch = line.match(/^\\s*([A-Z]+)\\[\"(.*?)\"\\]$/);\n      if (nodeMatch) {\n        const [, nodeId, fullText] = nodeMatch;\n\n        // Check if text starts with ✅ (completed)\n        const isCompleted = fullText.startsWith('✅');\n\n        // Clean text: remove ✅ or 📝 emojis and trim\n        let cleanText = fullText;\n        if (cleanText.startsWith('✅ ')) {\n          cleanText = cleanText.substring(2).trim();\n        } else if (cleanText.startsWith('📝 ')) {\n          cleanText = cleanText.substring(2).trim();\n        }\n        nodes.set(nodeId, {\n          text: cleanText.replace(/\\\\\"/g, '\"'),\n          completed: isCompleted\n        });\n        nodeOrder.push(nodeId);\n        continue;\n      }\n\n      // Parse connections: A --> B\n      const connectionMatch = line.match(/^\\s*([A-Z]+)\\s+-->\\s+([A-Z]+)$/);\n      if (connectionMatch) {\n        const [, parent, child] = connectionMatch;\n        if (!connections.has(parent)) {\n          connections.set(parent, []);\n        }\n        connections.get(parent).push(child);\n        continue;\n      }\n    }\n\n    // Validate we have at least one node\n    if (nodes.size === 0) {\n      return {\n        success: false,\n        error: 'No valid nodes found. Please check the format.'\n      };\n    }\n\n    // Validate maximum depth (4 levels)\n    const validateDepth = (nodeId, currentDepth = 0) => {\n      if (currentDepth > 3) return false; // Max 4 levels (0-3)\n\n      const children = connections.get(nodeId) || [];\n      return children.every(child => validateDepth(child, currentDepth + 1));\n    };\n\n    // Find root nodes (nodes with no parent)\n    const rootNodes = nodeOrder.filter(nodeId => !Array.from(connections.values()).some(children => children.includes(nodeId)));\n\n    // Validate depth for each root\n    if (!rootNodes.every(root => validateDepth(root))) {\n      return {\n        success: false,\n        error: 'Maximum 4 levels supported. Please simplify your structure.'\n      };\n    }\n\n    // Convert to Goal structure using proper positioning system\n    const goals = [];\n    let nextId = 1;\n\n    // We need a canvas width for positioning - use a reasonable default\n    const canvasWidth = 1200;\n\n    // Recursive function to process nodes with proper positioning\n    const processNode = (nodeId, level, parentId = null, parentGoal = null) => {\n      const nodeData = nodes.get(nodeId);\n      if (!nodeData) return;\n      const goalId = nextId++;\n\n      // Calculate proper position using existing grid system\n      let position;\n      if (level === 0) {\n        // Root goal: use standard grid positioning\n        const gridPosition = gridToPosition(level, 0, canvasWidth);\n        position = gridPosition;\n      } else if (parentGoal) {\n        // Child goal: use intelligent child positioning\n        const existingSiblings = goals.filter(g => g.parentId === parentId);\n        const childPosition = calculateChildPosition(parentGoal, existingSiblings, canvasWidth, 800 // Default canvas height\n        );\n        position = childPosition;\n      } else {\n        // Fallback to grid positioning\n        const gridPosition = gridToPosition(level, 0, canvasWidth);\n        position = gridPosition;\n      }\n      const goal = {\n        id: goalId,\n        text: nodeData.text,\n        completed: nodeData.completed,\n        level,\n        gridRow: Math.round((position.y - 40) / 140),\n        // Calculate gridRow from position\n        parentId,\n        position,\n        children: []\n      };\n      goals.push(goal);\n\n      // Process children\n      const children = connections.get(nodeId) || [];\n      children.forEach(childId => {\n        processNode(childId, level + 1, goalId, goal);\n      });\n    };\n\n    // Process all root nodes\n    rootNodes.forEach(rootId => {\n      processNode(rootId, 0, null, null);\n    });\n\n    // Update children arrays\n    goals.forEach(goal => {\n      goal.children = goals.filter(g => g.parentId === goal.id);\n    });\n    return {\n      success: true,\n      goals\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: `Parse error: ${error instanceof Error ? error.message : 'Unknown error'}`\n    };\n  }\n};","map":{"version":3,"names":["gridToPosition","calculateChildPosition","exportToMermaid","mainGoal","goals","length","lines","getNodeId","index","String","fromCharCode","sortedGoals","sort","a","b","level","id","goalToNodeId","Map","forEach","goal","set","nodeId","get","escapedText","text","replace","displayText","finalText","completed","push","childNodeId","parentId","parentNodeId","join","copyToClipboard","navigator","clipboard","window","isSecureContext","writeText","textArea","document","createElement","value","style","position","left","top","body","appendChild","focus","select","result","execCommand","removeChild","error","console","importFromMermaid","mermaidCode","trim","split","startsWith","success","nodes","connections","nodeOrder","i","line","nodeMatch","match","fullText","isCompleted","cleanText","substring","connectionMatch","parent","child","has","size","validateDepth","currentDepth","children","every","rootNodes","filter","Array","from","values","some","includes","root","nextId","canvasWidth","processNode","parentGoal","nodeData","goalId","gridPosition","existingSiblings","g","childPosition","gridRow","Math","round","y","childId","rootId","Error","message"],"sources":["C:/apps/goal-breaker/src/utils/mermaidHelpers.ts"],"sourcesContent":["import { Goal } from '../types/goal.types';\r\nimport { gridToPosition, calculateChildPosition } from './gridHelpers';\r\n\r\n/**\r\n * Convert goals structure to Mermaid diagram format\r\n * @param mainGoal - The main goal text (can be empty if using goals array)\r\n * @param goals - Array of goal objects\r\n * @returns Mermaid diagram string\r\n */\r\nexport const exportToMermaid = (mainGoal: string, goals: Goal[]): string => {\r\n  if (goals.length === 0) return '';\r\n  \r\n  const lines: string[] = ['graph TD'];\r\n  \r\n  // Generate unique node IDs (A, B, C, etc.)\r\n  const getNodeId = (index: number): string => {\r\n    return String.fromCharCode(65 + index); // A, B, C, D...\r\n  };\r\n  \r\n  // Sort goals by level and creation order for consistent output\r\n  const sortedGoals = [...goals].sort((a, b) => {\r\n    if (a.level !== b.level) return a.level - b.level;\r\n    return a.id - b.id;\r\n  });\r\n  \r\n  // Create mapping of goal.id to node ID\r\n  const goalToNodeId = new Map<number, string>();\r\n  sortedGoals.forEach((goal, index) => {\r\n    goalToNodeId.set(goal.id, getNodeId(index));\r\n  });\r\n  \r\n  // Add goal nodes\r\n  sortedGoals.forEach((goal) => {\r\n    const nodeId = goalToNodeId.get(goal.id);\r\n    const escapedText = goal.text.replace(/\"/g, '\\\"'); // Escape quotes\r\n    const displayText = goal.text || (goal.level === 0 ? 'Main Goal' : 'Untitled Task');\r\n    const finalText = goal.completed ? `✅ ${escapedText || displayText}` : escapedText || displayText;\r\n    lines.push(`    ${nodeId}[\"${finalText}\"]`);\r\n  });\r\n  \r\n  // Add connections\r\n  sortedGoals.forEach((goal) => {\r\n    const childNodeId = goalToNodeId.get(goal.id);\r\n    \r\n    if (goal.parentId !== null) {\r\n      // Connect to parent goal\r\n      const parentNodeId = goalToNodeId.get(goal.parentId);\r\n      if (parentNodeId) {\r\n        lines.push(`    ${parentNodeId} --> ${childNodeId}`);\r\n      }\r\n    }\r\n  });\r\n  \r\n  return lines.join('\\n');\r\n};;\r\n\r\n/**\r\n * Copy text to clipboard with fallback for older browsers\r\n * @param text - Text to copy\r\n * @returns Promise<boolean> - Success status\r\n */\r\nexport const copyToClipboard = async (text: string): Promise<boolean> => {\r\n  try {\r\n    if (navigator.clipboard && window.isSecureContext) {\r\n      await navigator.clipboard.writeText(text);\r\n      return true;\r\n    } else {\r\n      // Fallback for older browsers\r\n      const textArea = document.createElement('textarea');\r\n      textArea.value = text;\r\n      textArea.style.position = 'fixed';\r\n      textArea.style.left = '-999999px';\r\n      textArea.style.top = '-999999px';\r\n      document.body.appendChild(textArea);\r\n      textArea.focus();\r\n      textArea.select();\r\n      const result = document.execCommand('copy');\r\n      document.body.removeChild(textArea);\r\n      return result;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to copy to clipboard:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Parse Mermaid diagram format and convert to goals structure\r\n * @param mermaidCode - The Mermaid diagram string\r\n * @returns Object with success status and either goals array or error message\r\n */\r\nexport const importFromMermaid = (mermaidCode: string): { \r\n  success: boolean; \r\n  goals?: Goal[]; \r\n  error?: string \r\n} => {\r\n  try {\r\n    const lines = mermaidCode.trim().split('\\n');\r\n    \r\n    // Validate basic format\r\n    if (lines.length === 0 || !lines[0].trim().startsWith('graph TD')) {\r\n      return { \r\n        success: false, \r\n        error: 'Invalid format: Must start with \"graph TD\"' \r\n      };\r\n    }\r\n\r\n    const nodes = new Map<string, { text: string; completed: boolean }>();\r\n    const connections = new Map<string, string[]>(); // parent -> children\r\n    const nodeOrder: string[] = [];\r\n\r\n    // Parse nodes and connections\r\n    for (let i = 1; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      if (!line) continue;\r\n\r\n      // Parse node definitions: A[\"✅ Task text\"] or A[\"📝 Task text\"] or A[\"Task text\"]\r\n      const nodeMatch = line.match(/^\\s*([A-Z]+)\\[\"(.*?)\"\\]$/);\r\n      if (nodeMatch) {\r\n        const [, nodeId, fullText] = nodeMatch;\r\n        \r\n        // Check if text starts with ✅ (completed)\r\n        const isCompleted = fullText.startsWith('✅');\r\n        \r\n        // Clean text: remove ✅ or 📝 emojis and trim\r\n        let cleanText = fullText;\r\n        if (cleanText.startsWith('✅ ')) {\r\n          cleanText = cleanText.substring(2).trim();\r\n        } else if (cleanText.startsWith('📝 ')) {\r\n          cleanText = cleanText.substring(2).trim();\r\n        }\r\n        \r\n        nodes.set(nodeId, { \r\n          text: cleanText.replace(/\\\\\"/g, '\"'), \r\n          completed: isCompleted \r\n        });\r\n        nodeOrder.push(nodeId);\r\n        continue;\r\n      }\r\n\r\n      // Parse connections: A --> B\r\n      const connectionMatch = line.match(/^\\s*([A-Z]+)\\s+-->\\s+([A-Z]+)$/);\r\n      if (connectionMatch) {\r\n        const [, parent, child] = connectionMatch;\r\n        if (!connections.has(parent)) {\r\n          connections.set(parent, []);\r\n        }\r\n        connections.get(parent)!.push(child);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // Validate we have at least one node\r\n    if (nodes.size === 0) {\r\n      return { \r\n        success: false, \r\n        error: 'No valid nodes found. Please check the format.' \r\n      };\r\n    }\r\n\r\n    // Validate maximum depth (4 levels)\r\n    const validateDepth = (nodeId: string, currentDepth: number = 0): boolean => {\r\n      if (currentDepth > 3) return false; // Max 4 levels (0-3)\r\n      \r\n      const children = connections.get(nodeId) || [];\r\n      return children.every(child => validateDepth(child, currentDepth + 1));\r\n    };\r\n\r\n    // Find root nodes (nodes with no parent)\r\n    const rootNodes = nodeOrder.filter(nodeId => \r\n      !Array.from(connections.values()).some(children => children.includes(nodeId))\r\n    );\r\n\r\n    // Validate depth for each root\r\n    if (!rootNodes.every(root => validateDepth(root))) {\r\n      return { \r\n        success: false, \r\n        error: 'Maximum 4 levels supported. Please simplify your structure.' \r\n      };\r\n    }\r\n\r\n    // Convert to Goal structure using proper positioning system\r\n    const goals: Goal[] = [];\r\n    let nextId = 1;\r\n    \r\n    // We need a canvas width for positioning - use a reasonable default\r\n    const canvasWidth = 1200;\r\n    \r\n    // Recursive function to process nodes with proper positioning\r\n    const processNode = (\r\n      nodeId: string, \r\n      level: number, \r\n      parentId: number | null = null,\r\n      parentGoal: Goal | null = null\r\n    ): void => {\r\n      const nodeData = nodes.get(nodeId);\r\n      if (!nodeData) return;\r\n\r\n      const goalId = nextId++;\r\n      \r\n      // Calculate proper position using existing grid system\r\n      let position: { x: number; y: number };\r\n      \r\n      if (level === 0) {\r\n        // Root goal: use standard grid positioning\r\n        const gridPosition = gridToPosition(level, 0, canvasWidth);\r\n        position = gridPosition;\r\n      } else if (parentGoal) {\r\n        // Child goal: use intelligent child positioning\r\n        const existingSiblings = goals.filter(g => g.parentId === parentId);\r\n        const childPosition = calculateChildPosition(\r\n          parentGoal, \r\n          existingSiblings, \r\n          canvasWidth, \r\n          800 // Default canvas height\r\n        );\r\n        position = childPosition;\r\n      } else {\r\n        // Fallback to grid positioning\r\n        const gridPosition = gridToPosition(level, 0, canvasWidth);\r\n        position = gridPosition;\r\n      }\r\n\r\n      const goal: Goal = {\r\n        id: goalId,\r\n        text: nodeData.text,\r\n        completed: nodeData.completed,\r\n        level,\r\n        gridRow: Math.round((position.y - 40) / 140), // Calculate gridRow from position\r\n        parentId,\r\n        position,\r\n        children: []\r\n      };\r\n\r\n      goals.push(goal);\r\n\r\n      // Process children\r\n      const children = connections.get(nodeId) || [];\r\n      children.forEach((childId) => {\r\n        processNode(childId, level + 1, goalId, goal);\r\n      });\r\n    };\r\n\r\n\r\n\r\n    // Process all root nodes\r\n    rootNodes.forEach((rootId) => {\r\n      processNode(rootId, 0, null, null);\r\n    });\r\n\r\n    // Update children arrays\r\n    goals.forEach(goal => {\r\n      goal.children = goals.filter(g => g.parentId === goal.id);\r\n    });\r\n\r\n    return { success: true, goals };\r\n\r\n  } catch (error) {\r\n    return { \r\n      success: false, \r\n      error: `Parse error: ${error instanceof Error ? error.message : 'Unknown error'}` \r\n    };\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}