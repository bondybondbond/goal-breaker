{"ast":null,"code":"export const GRID = {\n  COLUMN_WIDTH: 400,\n  ROW_HEIGHT: 140,\n  CARD_WIDTH: 320,\n  CARD_HEIGHT: 120,\n  MARGIN: 40\n};\n\n// Convert grid coordinates to pixel position\nexport const gridToPosition = (level, row, canvasWidth) => {\n  // Right-to-left layout: level 0 (ultimate goal) is on the right, subsequent levels go left\n  const x = canvasWidth - GRID.MARGIN - (level + 1) * GRID.COLUMN_WIDTH;\n  const y = GRID.MARGIN + row * GRID.ROW_HEIGHT;\n  return {\n    x: Math.max(GRID.MARGIN, x),\n    y: Math.max(GRID.MARGIN, y)\n  };\n};\n\n// Convert pixel position to grid coordinates\nexport const positionToGrid = (position, canvasWidth) => {\n  const level = Math.max(0, Math.round((canvasWidth - position.x - GRID.CARD_WIDTH - GRID.MARGIN) / GRID.COLUMN_WIDTH));\n  const row = Math.max(0, Math.round((position.y - GRID.MARGIN) / GRID.ROW_HEIGHT));\n  return {\n    level,\n    row\n  };\n};\n\n// Get next available row for a level\nexport const getNextRowForLevel = (level, goals) => {\n  const levelGoals = goals.filter(g => g.level === level);\n  if (levelGoals.length === 0) return 0;\n  const occupiedRows = levelGoals.map(g => g.gridRow).sort((a, b) => a - b);\n  let nextRow = 0;\n  for (const row of occupiedRows) {\n    if (row === nextRow) {\n      nextRow++;\n    } else {\n      break;\n    }\n  }\n  return nextRow;\n};\n\n// Calculate position for new goal\nexport const calculateNewGoalPosition = (parentId, goals, canvasWidth) => {\n  const parent = goals.find(g => g.id === parentId);\n  if (!parent) throw new Error(\"Parent goal not found\");\n  const newLevel = parent.level + 1;\n  const newRow = getNextRowForLevel(newLevel, goals);\n  const newPosition = gridToPosition(newLevel, newRow, canvasWidth);\n  return {\n    level: newLevel,\n    row: newRow,\n    position: newPosition\n  };\n};\n\n// Calculate balanced position for child goals relative to their parent\nexport const calculateChildPosition = (parentGoal, siblingGoals, canvasWidth, canvasHeight) => {\n  const newLevel = parentGoal.level + 1;\n  const childrenCount = siblingGoals.length + 1; // +1 for the new child\n\n  // Position children to the left of parent\n  const x = canvasWidth - GRID.MARGIN - (newLevel + 1) * GRID.COLUMN_WIDTH;\n\n  // Get existing siblings positions to find the next available vertical position\n  const existingYPositions = siblingGoals.map(sibling => sibling.position.y).sort((a, b) => a - b);\n  let newY;\n  if (childrenCount === 1) {\n    // First child: place at parent's vertical position\n    newY = parentGoal.position.y;\n  } else {\n    // Find next available row position that doesn't overlap\n    const parentCenterY = parentGoal.position.y + GRID.CARD_HEIGHT / 2;\n    const startSearchY = Math.max(GRID.MARGIN, parentCenterY - Math.floor(childrenCount / 2) * GRID.ROW_HEIGHT);\n\n    // Try positions starting from above the parent and working down\n    newY = startSearchY;\n    let attempts = 0;\n    const maxAttempts = 20; // Prevent infinite loops\n\n    while (attempts < maxAttempts) {\n      // Check if this position overlaps with any existing siblings\n      const overlaps = existingYPositions.some(existingY => Math.abs(newY - existingY) < GRID.ROW_HEIGHT - 10 // 10px buffer\n      );\n      if (!overlaps) {\n        break; // Found a good position\n      }\n\n      // Try next position down\n      newY += GRID.ROW_HEIGHT;\n      attempts++;\n    }\n\n    // Ensure we don't go below canvas bounds\n    newY = Math.min(newY, canvasHeight - GRID.CARD_HEIGHT - GRID.MARGIN);\n  }\n  return {\n    x: Math.max(GRID.MARGIN, x),\n    y: Math.max(GRID.MARGIN, newY)\n  };\n};\n;","map":{"version":3,"names":["GRID","COLUMN_WIDTH","ROW_HEIGHT","CARD_WIDTH","CARD_HEIGHT","MARGIN","gridToPosition","level","row","canvasWidth","x","y","Math","max","positionToGrid","position","round","getNextRowForLevel","goals","levelGoals","filter","g","length","occupiedRows","map","gridRow","sort","a","b","nextRow","calculateNewGoalPosition","parentId","parent","find","id","Error","newLevel","newRow","newPosition","calculateChildPosition","parentGoal","siblingGoals","canvasHeight","childrenCount","existingYPositions","sibling","newY","parentCenterY","startSearchY","floor","attempts","maxAttempts","overlaps","some","existingY","abs","min"],"sources":["C:/apps/goal-breaker/src/utils/gridHelpers.ts"],"sourcesContent":["import { Goal, Position, GridConfig } from \"../types/goal.types\";\r\n\r\nexport const GRID: GridConfig = {\r\n  COLUMN_WIDTH: 400,\r\n  ROW_HEIGHT: 140,\r\n  CARD_WIDTH: 320,\r\n  CARD_HEIGHT: 120,\r\n  MARGIN: 40\r\n};\r\n\r\n// Convert grid coordinates to pixel position\r\nexport const gridToPosition = (level: number, row: number, canvasWidth: number): Position => {\r\n  // Right-to-left layout: level 0 (ultimate goal) is on the right, subsequent levels go left\r\n  const x = canvasWidth - GRID.MARGIN - ((level + 1) * GRID.COLUMN_WIDTH);\r\n  const y = GRID.MARGIN + (row * GRID.ROW_HEIGHT);\r\n  \r\n  return {\r\n    x: Math.max(GRID.MARGIN, x),\r\n    y: Math.max(GRID.MARGIN, y)\r\n  };\r\n};\r\n\r\n// Convert pixel position to grid coordinates\r\nexport const positionToGrid = (position: Position, canvasWidth: number) => {\r\n  const level = Math.max(0, Math.round((canvasWidth - position.x - GRID.CARD_WIDTH - GRID.MARGIN) / GRID.COLUMN_WIDTH));\r\n  const row = Math.max(0, Math.round((position.y - GRID.MARGIN) / GRID.ROW_HEIGHT));\r\n  \r\n  return { level, row };\r\n};\r\n\r\n// Get next available row for a level\r\nexport const getNextRowForLevel = (level: number, goals: Goal[]): number => {\r\n  const levelGoals = goals.filter(g => g.level === level);\r\n  if (levelGoals.length === 0) return 0;\r\n  \r\n  const occupiedRows = levelGoals.map(g => g.gridRow).sort((a, b) => a - b);\r\n  let nextRow = 0;\r\n  \r\n  for (const row of occupiedRows) {\r\n    if (row === nextRow) {\r\n      nextRow++;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  \r\n  return nextRow;\r\n};\r\n\r\n// Calculate position for new goal\r\nexport const calculateNewGoalPosition = (\r\n  parentId: number,\r\n  goals: Goal[],\r\n  canvasWidth: number\r\n): { level: number; row: number; position: Position } => {\r\n  const parent = goals.find(g => g.id === parentId);\r\n  if (!parent) throw new Error(\"Parent goal not found\");\r\n  \r\n  const newLevel = parent.level + 1;\r\n  const newRow = getNextRowForLevel(newLevel, goals);\r\n  const newPosition = gridToPosition(newLevel, newRow, canvasWidth);\r\n  \r\n  return {\r\n    level: newLevel,\r\n    row: newRow,\r\n    position: newPosition\r\n  };\r\n};\r\n\r\n// Calculate balanced position for child goals relative to their parent\r\nexport const calculateChildPosition = (\r\n  parentGoal: Goal,\r\n  siblingGoals: Goal[],\r\n  canvasWidth: number,\r\n  canvasHeight: number\r\n): Position => {\r\n  const newLevel = parentGoal.level + 1;\r\n  const childrenCount = siblingGoals.length + 1; // +1 for the new child\r\n  \r\n  // Position children to the left of parent\r\n  const x = canvasWidth - GRID.MARGIN - ((newLevel + 1) * GRID.COLUMN_WIDTH);\r\n  \r\n  // Get existing siblings positions to find the next available vertical position\r\n  const existingYPositions = siblingGoals.map(sibling => sibling.position.y).sort((a, b) => a - b);\r\n  \r\n  let newY;\r\n  \r\n  if (childrenCount === 1) {\r\n    // First child: place at parent's vertical position\r\n    newY = parentGoal.position.y;\r\n  } else {\r\n    // Find next available row position that doesn't overlap\r\n    const parentCenterY = parentGoal.position.y + (GRID.CARD_HEIGHT / 2);\r\n    const startSearchY = Math.max(GRID.MARGIN, parentCenterY - (Math.floor(childrenCount / 2) * GRID.ROW_HEIGHT));\r\n    \r\n    // Try positions starting from above the parent and working down\r\n    newY = startSearchY;\r\n    let attempts = 0;\r\n    const maxAttempts = 20; // Prevent infinite loops\r\n    \r\n    while (attempts < maxAttempts) {\r\n      // Check if this position overlaps with any existing siblings\r\n      const overlaps = existingYPositions.some(existingY => \r\n        Math.abs(newY - existingY) < GRID.ROW_HEIGHT - 10 // 10px buffer\r\n      );\r\n      \r\n      if (!overlaps) {\r\n        break; // Found a good position\r\n      }\r\n      \r\n      // Try next position down\r\n      newY += GRID.ROW_HEIGHT;\r\n      attempts++;\r\n    }\r\n    \r\n    // Ensure we don't go below canvas bounds\r\n    newY = Math.min(newY, canvasHeight - GRID.CARD_HEIGHT - GRID.MARGIN);\r\n  }\r\n  \r\n  return {\r\n    x: Math.max(GRID.MARGIN, x),\r\n    y: Math.max(GRID.MARGIN, newY)\r\n  };\r\n};;\r\n"],"mappings":"AAEA,OAAO,MAAMA,IAAgB,GAAG;EAC9BC,YAAY,EAAE,GAAG;EACjBC,UAAU,EAAE,GAAG;EACfC,UAAU,EAAE,GAAG;EACfC,WAAW,EAAE,GAAG;EAChBC,MAAM,EAAE;AACV,CAAC;;AAED;AACA,OAAO,MAAMC,cAAc,GAAGA,CAACC,KAAa,EAAEC,GAAW,EAAEC,WAAmB,KAAe;EAC3F;EACA,MAAMC,CAAC,GAAGD,WAAW,GAAGT,IAAI,CAACK,MAAM,GAAI,CAACE,KAAK,GAAG,CAAC,IAAIP,IAAI,CAACC,YAAa;EACvE,MAAMU,CAAC,GAAGX,IAAI,CAACK,MAAM,GAAIG,GAAG,GAAGR,IAAI,CAACE,UAAW;EAE/C,OAAO;IACLQ,CAAC,EAAEE,IAAI,CAACC,GAAG,CAACb,IAAI,CAACK,MAAM,EAAEK,CAAC,CAAC;IAC3BC,CAAC,EAAEC,IAAI,CAACC,GAAG,CAACb,IAAI,CAACK,MAAM,EAAEM,CAAC;EAC5B,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMG,cAAc,GAAGA,CAACC,QAAkB,EAAEN,WAAmB,KAAK;EACzE,MAAMF,KAAK,GAAGK,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACI,KAAK,CAAC,CAACP,WAAW,GAAGM,QAAQ,CAACL,CAAC,GAAGV,IAAI,CAACG,UAAU,GAAGH,IAAI,CAACK,MAAM,IAAIL,IAAI,CAACC,YAAY,CAAC,CAAC;EACrH,MAAMO,GAAG,GAAGI,IAAI,CAACC,GAAG,CAAC,CAAC,EAAED,IAAI,CAACI,KAAK,CAAC,CAACD,QAAQ,CAACJ,CAAC,GAAGX,IAAI,CAACK,MAAM,IAAIL,IAAI,CAACE,UAAU,CAAC,CAAC;EAEjF,OAAO;IAAEK,KAAK;IAAEC;EAAI,CAAC;AACvB,CAAC;;AAED;AACA,OAAO,MAAMS,kBAAkB,GAAGA,CAACV,KAAa,EAAEW,KAAa,KAAa;EAC1E,MAAMC,UAAU,GAAGD,KAAK,CAACE,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACd,KAAK,KAAKA,KAAK,CAAC;EACvD,IAAIY,UAAU,CAACG,MAAM,KAAK,CAAC,EAAE,OAAO,CAAC;EAErC,MAAMC,YAAY,GAAGJ,UAAU,CAACK,GAAG,CAACH,CAAC,IAAIA,CAAC,CAACI,OAAO,CAAC,CAACC,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;EACzE,IAAIC,OAAO,GAAG,CAAC;EAEf,KAAK,MAAMrB,GAAG,IAAIe,YAAY,EAAE;IAC9B,IAAIf,GAAG,KAAKqB,OAAO,EAAE;MACnBA,OAAO,EAAE;IACX,CAAC,MAAM;MACL;IACF;EACF;EAEA,OAAOA,OAAO;AAChB,CAAC;;AAED;AACA,OAAO,MAAMC,wBAAwB,GAAGA,CACtCC,QAAgB,EAChBb,KAAa,EACbT,WAAmB,KACoC;EACvD,MAAMuB,MAAM,GAAGd,KAAK,CAACe,IAAI,CAACZ,CAAC,IAAIA,CAAC,CAACa,EAAE,KAAKH,QAAQ,CAAC;EACjD,IAAI,CAACC,MAAM,EAAE,MAAM,IAAIG,KAAK,CAAC,uBAAuB,CAAC;EAErD,MAAMC,QAAQ,GAAGJ,MAAM,CAACzB,KAAK,GAAG,CAAC;EACjC,MAAM8B,MAAM,GAAGpB,kBAAkB,CAACmB,QAAQ,EAAElB,KAAK,CAAC;EAClD,MAAMoB,WAAW,GAAGhC,cAAc,CAAC8B,QAAQ,EAAEC,MAAM,EAAE5B,WAAW,CAAC;EAEjE,OAAO;IACLF,KAAK,EAAE6B,QAAQ;IACf5B,GAAG,EAAE6B,MAAM;IACXtB,QAAQ,EAAEuB;EACZ,CAAC;AACH,CAAC;;AAED;AACA,OAAO,MAAMC,sBAAsB,GAAGA,CACpCC,UAAgB,EAChBC,YAAoB,EACpBhC,WAAmB,EACnBiC,YAAoB,KACP;EACb,MAAMN,QAAQ,GAAGI,UAAU,CAACjC,KAAK,GAAG,CAAC;EACrC,MAAMoC,aAAa,GAAGF,YAAY,CAACnB,MAAM,GAAG,CAAC,CAAC,CAAC;;EAE/C;EACA,MAAMZ,CAAC,GAAGD,WAAW,GAAGT,IAAI,CAACK,MAAM,GAAI,CAAC+B,QAAQ,GAAG,CAAC,IAAIpC,IAAI,CAACC,YAAa;;EAE1E;EACA,MAAM2C,kBAAkB,GAAGH,YAAY,CAACjB,GAAG,CAACqB,OAAO,IAAIA,OAAO,CAAC9B,QAAQ,CAACJ,CAAC,CAAC,CAACe,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,GAAGC,CAAC,CAAC;EAEhG,IAAIkB,IAAI;EAER,IAAIH,aAAa,KAAK,CAAC,EAAE;IACvB;IACAG,IAAI,GAAGN,UAAU,CAACzB,QAAQ,CAACJ,CAAC;EAC9B,CAAC,MAAM;IACL;IACA,MAAMoC,aAAa,GAAGP,UAAU,CAACzB,QAAQ,CAACJ,CAAC,GAAIX,IAAI,CAACI,WAAW,GAAG,CAAE;IACpE,MAAM4C,YAAY,GAAGpC,IAAI,CAACC,GAAG,CAACb,IAAI,CAACK,MAAM,EAAE0C,aAAa,GAAInC,IAAI,CAACqC,KAAK,CAACN,aAAa,GAAG,CAAC,CAAC,GAAG3C,IAAI,CAACE,UAAW,CAAC;;IAE7G;IACA4C,IAAI,GAAGE,YAAY;IACnB,IAAIE,QAAQ,GAAG,CAAC;IAChB,MAAMC,WAAW,GAAG,EAAE,CAAC,CAAC;;IAExB,OAAOD,QAAQ,GAAGC,WAAW,EAAE;MAC7B;MACA,MAAMC,QAAQ,GAAGR,kBAAkB,CAACS,IAAI,CAACC,SAAS,IAChD1C,IAAI,CAAC2C,GAAG,CAACT,IAAI,GAAGQ,SAAS,CAAC,GAAGtD,IAAI,CAACE,UAAU,GAAG,EAAE,CAAC;MACpD,CAAC;MAED,IAAI,CAACkD,QAAQ,EAAE;QACb,MAAM,CAAC;MACT;;MAEA;MACAN,IAAI,IAAI9C,IAAI,CAACE,UAAU;MACvBgD,QAAQ,EAAE;IACZ;;IAEA;IACAJ,IAAI,GAAGlC,IAAI,CAAC4C,GAAG,CAACV,IAAI,EAAEJ,YAAY,GAAG1C,IAAI,CAACI,WAAW,GAAGJ,IAAI,CAACK,MAAM,CAAC;EACtE;EAEA,OAAO;IACLK,CAAC,EAAEE,IAAI,CAACC,GAAG,CAACb,IAAI,CAACK,MAAM,EAAEK,CAAC,CAAC;IAC3BC,CAAC,EAAEC,IAAI,CAACC,GAAG,CAACb,IAAI,CAACK,MAAM,EAAEyC,IAAI;EAC/B,CAAC;AACH,CAAC;AAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}