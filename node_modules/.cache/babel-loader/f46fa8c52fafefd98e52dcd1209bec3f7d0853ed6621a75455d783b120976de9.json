{"ast":null,"code":"export const GRID={COLUMN_WIDTH:400,ROW_HEIGHT:140,CARD_WIDTH:320,CARD_HEIGHT:120,MARGIN:40};// Convert grid coordinates to pixel position\nexport const gridToPosition=(level,row,canvasWidth)=>{// Right-to-left layout: level 0 (ultimate goal) is on the right, subsequent levels go left\nconst x=canvasWidth-GRID.MARGIN-(level+1)*GRID.COLUMN_WIDTH;const y=GRID.MARGIN+row*GRID.ROW_HEIGHT;return{x:Math.max(GRID.MARGIN,x),y:Math.max(GRID.MARGIN,y)};};// Convert pixel position to grid coordinates\nexport const positionToGrid=(position,canvasWidth)=>{const level=Math.max(0,Math.round((canvasWidth-position.x-GRID.CARD_WIDTH-GRID.MARGIN)/GRID.COLUMN_WIDTH));const row=Math.max(0,Math.round((position.y-GRID.MARGIN)/GRID.ROW_HEIGHT));return{level,row};};// Get next available row for a level\nexport const getNextRowForLevel=(level,goals)=>{const levelGoals=goals.filter(g=>g.level===level);if(levelGoals.length===0)return 0;const occupiedRows=levelGoals.map(g=>g.gridRow).sort((a,b)=>a-b);let nextRow=0;for(const row of occupiedRows){if(row===nextRow){nextRow++;}else{break;}}return nextRow;};// Calculate position for new goal\nexport const calculateNewGoalPosition=(parentId,goals,canvasWidth)=>{const parent=goals.find(g=>g.id===parentId);if(!parent)throw new Error(\"Parent goal not found\");const newLevel=parent.level+1;const newRow=getNextRowForLevel(newLevel,goals);const newPosition=gridToPosition(newLevel,newRow,canvasWidth);return{level:newLevel,row:newRow,position:newPosition};};// Calculate balanced position for child goals relative to their parent\nexport const calculateChildPosition=(parentGoal,siblingGoals,canvasWidth,canvasHeight)=>{const newLevel=parentGoal.level+1;const childrenCount=siblingGoals.length+1;// +1 for the new child\n// Position children to the left of parent\nconst x=canvasWidth-GRID.MARGIN-(newLevel+1)*GRID.COLUMN_WIDTH;if(childrenCount===1){// First child: place at parent's vertical position\nreturn{x:Math.max(GRID.MARGIN,x),y:Math.max(GRID.MARGIN,parentGoal.position.y)};}// For multiple children, create a smart grid system\n// Get all existing sibling Y positions and sort them\nconst existingYPositions=siblingGoals.map(sibling=>sibling.position.y).sort((a,b)=>a-b);// Create a grid of possible positions centered around parent\nconst parentCenterY=parentGoal.position.y+GRID.CARD_HEIGHT/2;const gridSpacing=GRID.ROW_HEIGHT;// Generate potential positions in both directions from parent\nconst potentialPositions=[];// Start with parent's position\npotentialPositions.push(parentGoal.position.y);// Add positions above and below parent alternately\nfor(let i=1;i<=childrenCount+2;i++){const offsetAbove=parentGoal.position.y-i*gridSpacing;const offsetBelow=parentGoal.position.y+i*gridSpacing;// Add above position if within bounds\nif(offsetAbove>=GRID.MARGIN){potentialPositions.push(offsetAbove);}// Add below position if within bounds\nif(offsetBelow+GRID.CARD_HEIGHT<=canvasHeight-GRID.MARGIN){potentialPositions.push(offsetBelow);}}// Find the first position that doesn't conflict with existing siblings\nfor(const candidateY of potentialPositions){let hasConflict=false;for(const existingY of existingYPositions){// Check if cards would overlap (with safety margin)\nconst minDistance=GRID.CARD_HEIGHT+20;// 20px safety margin\nif(Math.abs(candidateY-existingY)<minDistance){hasConflict=true;break;}}if(!hasConflict){return{x:Math.max(GRID.MARGIN,x),y:Math.max(GRID.MARGIN,candidateY)};}}// Fallback: if no position found, place at bottom with extra spacing\nconst lastExistingY=existingYPositions[existingYPositions.length-1]||parentGoal.position.y;const fallbackY=lastExistingY+GRID.ROW_HEIGHT;return{x:Math.max(GRID.MARGIN,x),y:Math.max(GRID.MARGIN,Math.min(fallbackY,canvasHeight-GRID.CARD_HEIGHT-GRID.MARGIN))};};/**\r\n * Calculate standardized positions for a complete goal hierarchy\r\n * This ensures consistent positioning regardless of how goals are created\r\n * @param goals - Array of goals with hierarchy info\r\n * @param canvasWidth - Width of the canvas\r\n * @param canvasHeight - Height of the canvas\r\n * @returns Goals with standardized positions\r\n */export const standardizeGoalPositions=(goals,canvasWidth,canvasHeight)=>{// Group goals by level\nconst levelGroups=new Map();goals.forEach(goal=>{if(!levelGroups.has(goal.level)){levelGroups.set(goal.level,[]);}levelGroups.get(goal.level).push(goal);});// Position level 0 (main goal) at center-right of canvas\nconst level0Goals=levelGroups.get(0)||[];level0Goals.forEach((goal,index)=>{const centerY=canvasHeight/2-GRID.CARD_HEIGHT/2;const offsetY=index*GRID.ROW_HEIGHT;// Use consistent positioning formula: level 0 is at (0 + 1) * COLUMN_WIDTH from the right\ngoal.position={x:canvasWidth-GRID.MARGIN-GRID.COLUMN_WIDTH,y:centerY+offsetY};});// Position each subsequent level relative to their parents\nfor(let level=1;level<=3;level++){const levelGoals=levelGroups.get(level)||[];// Group goals by parent\nconst parentGroups=new Map();levelGoals.forEach(goal=>{if(goal.parentId!==null){if(!parentGroups.has(goal.parentId)){parentGroups.set(goal.parentId,[]);}parentGroups.get(goal.parentId).push(goal);}});// Position each group of siblings\nparentGroups.forEach((siblings,parentId)=>{const parent=goals.find(g=>g.id===parentId);if(!parent)return;const x=canvasWidth-GRID.MARGIN-(level+1)*GRID.COLUMN_WIDTH;// Center siblings around parent\nconst siblingCount=siblings.length;const totalHeight=siblingCount*GRID.ROW_HEIGHT;const startY=parent.position.y+GRID.CARD_HEIGHT/2-totalHeight/2;siblings.forEach((sibling,index)=>{sibling.position={x:Math.max(GRID.MARGIN,x),y:Math.max(GRID.MARGIN,startY+index*GRID.ROW_HEIGHT)};});});}return goals;};","map":{"version":3,"names":["GRID","COLUMN_WIDTH","ROW_HEIGHT","CARD_WIDTH","CARD_HEIGHT","MARGIN","gridToPosition","level","row","canvasWidth","x","y","Math","max","positionToGrid","position","round","getNextRowForLevel","goals","levelGoals","filter","g","length","occupiedRows","map","gridRow","sort","a","b","nextRow","calculateNewGoalPosition","parentId","parent","find","id","Error","newLevel","newRow","newPosition","calculateChildPosition","parentGoal","siblingGoals","canvasHeight","childrenCount","existingYPositions","sibling","parentCenterY","gridSpacing","potentialPositions","push","i","offsetAbove","offsetBelow","candidateY","hasConflict","existingY","minDistance","abs","lastExistingY","fallbackY","min","standardizeGoalPositions","levelGroups","Map","forEach","goal","has","set","get","level0Goals","index","centerY","offsetY","parentGroups","siblings","siblingCount","totalHeight","startY"],"sources":["C:/apps/goal-breaker/src/utils/gridHelpers.ts"],"sourcesContent":["import { Goal, Position, GridConfig } from \"../types/goal.types\";\r\n\r\nexport const GRID: GridConfig = {\r\n  COLUMN_WIDTH: 400,\r\n  ROW_HEIGHT: 140,\r\n  CARD_WIDTH: 320,\r\n  CARD_HEIGHT: 120,\r\n  MARGIN: 40\r\n};\r\n\r\n// Convert grid coordinates to pixel position\r\nexport const gridToPosition = (level: number, row: number, canvasWidth: number): Position => {\r\n  // Right-to-left layout: level 0 (ultimate goal) is on the right, subsequent levels go left\r\n  const x = canvasWidth - GRID.MARGIN - ((level + 1) * GRID.COLUMN_WIDTH);\r\n  const y = GRID.MARGIN + (row * GRID.ROW_HEIGHT);\r\n  \r\n  return {\r\n    x: Math.max(GRID.MARGIN, x),\r\n    y: Math.max(GRID.MARGIN, y)\r\n  };\r\n};\r\n\r\n// Convert pixel position to grid coordinates\r\nexport const positionToGrid = (position: Position, canvasWidth: number) => {\r\n  const level = Math.max(0, Math.round((canvasWidth - position.x - GRID.CARD_WIDTH - GRID.MARGIN) / GRID.COLUMN_WIDTH));\r\n  const row = Math.max(0, Math.round((position.y - GRID.MARGIN) / GRID.ROW_HEIGHT));\r\n  \r\n  return { level, row };\r\n};\r\n\r\n// Get next available row for a level\r\nexport const getNextRowForLevel = (level: number, goals: Goal[]): number => {\r\n  const levelGoals = goals.filter(g => g.level === level);\r\n  if (levelGoals.length === 0) return 0;\r\n  \r\n  const occupiedRows = levelGoals.map(g => g.gridRow).sort((a, b) => a - b);\r\n  let nextRow = 0;\r\n  \r\n  for (const row of occupiedRows) {\r\n    if (row === nextRow) {\r\n      nextRow++;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  \r\n  return nextRow;\r\n};\r\n\r\n// Calculate position for new goal\r\nexport const calculateNewGoalPosition = (\r\n  parentId: number,\r\n  goals: Goal[],\r\n  canvasWidth: number\r\n): { level: number; row: number; position: Position } => {\r\n  const parent = goals.find(g => g.id === parentId);\r\n  if (!parent) throw new Error(\"Parent goal not found\");\r\n  \r\n  const newLevel = parent.level + 1;\r\n  const newRow = getNextRowForLevel(newLevel, goals);\r\n  const newPosition = gridToPosition(newLevel, newRow, canvasWidth);\r\n  \r\n  return {\r\n    level: newLevel,\r\n    row: newRow,\r\n    position: newPosition\r\n  };\r\n};\r\n\r\n// Calculate balanced position for child goals relative to their parent\r\nexport const calculateChildPosition = (\r\n  parentGoal: Goal,\r\n  siblingGoals: Goal[],\r\n  canvasWidth: number,\r\n  canvasHeight: number\r\n): Position => {\r\n  const newLevel = parentGoal.level + 1;\r\n  const childrenCount = siblingGoals.length + 1; // +1 for the new child\r\n  \r\n  // Position children to the left of parent\r\n  const x = canvasWidth - GRID.MARGIN - ((newLevel + 1) * GRID.COLUMN_WIDTH);\r\n  \r\n  if (childrenCount === 1) {\r\n    // First child: place at parent's vertical position\r\n    return {\r\n      x: Math.max(GRID.MARGIN, x),\r\n      y: Math.max(GRID.MARGIN, parentGoal.position.y)\r\n    };\r\n  }\r\n  \r\n  // For multiple children, create a smart grid system\r\n  // Get all existing sibling Y positions and sort them\r\n  const existingYPositions = siblingGoals\r\n    .map(sibling => sibling.position.y)\r\n    .sort((a, b) => a - b);\r\n  \r\n  // Create a grid of possible positions centered around parent\r\n  const parentCenterY = parentGoal.position.y + (GRID.CARD_HEIGHT / 2);\r\n  const gridSpacing = GRID.ROW_HEIGHT;\r\n  \r\n  // Generate potential positions in both directions from parent\r\n  const potentialPositions: number[] = [];\r\n  \r\n  // Start with parent's position\r\n  potentialPositions.push(parentGoal.position.y);\r\n  \r\n  // Add positions above and below parent alternately\r\n  for (let i = 1; i <= childrenCount + 2; i++) {\r\n    const offsetAbove = parentGoal.position.y - (i * gridSpacing);\r\n    const offsetBelow = parentGoal.position.y + (i * gridSpacing);\r\n    \r\n    // Add above position if within bounds\r\n    if (offsetAbove >= GRID.MARGIN) {\r\n      potentialPositions.push(offsetAbove);\r\n    }\r\n    \r\n    // Add below position if within bounds\r\n    if (offsetBelow + GRID.CARD_HEIGHT <= canvasHeight - GRID.MARGIN) {\r\n      potentialPositions.push(offsetBelow);\r\n    }\r\n  }\r\n  \r\n  // Find the first position that doesn't conflict with existing siblings\r\n  for (const candidateY of potentialPositions) {\r\n    let hasConflict = false;\r\n    \r\n    for (const existingY of existingYPositions) {\r\n      // Check if cards would overlap (with safety margin)\r\n      const minDistance = GRID.CARD_HEIGHT + 20; // 20px safety margin\r\n      if (Math.abs(candidateY - existingY) < minDistance) {\r\n        hasConflict = true;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (!hasConflict) {\r\n      return {\r\n        x: Math.max(GRID.MARGIN, x),\r\n        y: Math.max(GRID.MARGIN, candidateY)\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Fallback: if no position found, place at bottom with extra spacing\r\n  const lastExistingY = existingYPositions[existingYPositions.length - 1] || parentGoal.position.y;\r\n  const fallbackY = lastExistingY + GRID.ROW_HEIGHT;\r\n  \r\n  return {\r\n    x: Math.max(GRID.MARGIN, x),\r\n    y: Math.max(GRID.MARGIN, Math.min(fallbackY, canvasHeight - GRID.CARD_HEIGHT - GRID.MARGIN))\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate standardized positions for a complete goal hierarchy\r\n * This ensures consistent positioning regardless of how goals are created\r\n * @param goals - Array of goals with hierarchy info\r\n * @param canvasWidth - Width of the canvas\r\n * @param canvasHeight - Height of the canvas\r\n * @returns Goals with standardized positions\r\n */\r\nexport const standardizeGoalPositions = (\r\n  goals: Goal[],\r\n  canvasWidth: number,\r\n  canvasHeight: number\r\n): Goal[] => {\r\n  // Group goals by level\r\n  const levelGroups = new Map<number, Goal[]>();\r\n  goals.forEach(goal => {\r\n    if (!levelGroups.has(goal.level)) {\r\n      levelGroups.set(goal.level, []);\r\n    }\r\n    levelGroups.get(goal.level)!.push(goal);\r\n  });\r\n  \r\n  // Position level 0 (main goal) at center-right of canvas\r\n  const level0Goals = levelGroups.get(0) || [];\r\n  level0Goals.forEach((goal, index) => {\r\n    const centerY = (canvasHeight / 2) - (GRID.CARD_HEIGHT / 2);\r\n    const offsetY = index * GRID.ROW_HEIGHT;\r\n    // Use consistent positioning formula: level 0 is at (0 + 1) * COLUMN_WIDTH from the right\r\n    goal.position = {\r\n      x: canvasWidth - GRID.MARGIN - GRID.COLUMN_WIDTH,\r\n      y: centerY + offsetY\r\n    };\r\n  });\r\n  \r\n  // Position each subsequent level relative to their parents\r\n  for (let level = 1; level <= 3; level++) {\r\n    const levelGoals = levelGroups.get(level) || [];\r\n    \r\n    // Group goals by parent\r\n    const parentGroups = new Map<number, Goal[]>();\r\n    levelGoals.forEach(goal => {\r\n      if (goal.parentId !== null) {\r\n        if (!parentGroups.has(goal.parentId)) {\r\n          parentGroups.set(goal.parentId, []);\r\n        }\r\n        parentGroups.get(goal.parentId)!.push(goal);\r\n      }\r\n    });\r\n    \r\n    // Position each group of siblings\r\n    parentGroups.forEach((siblings, parentId) => {\r\n      const parent = goals.find(g => g.id === parentId);\r\n      if (!parent) return;\r\n      \r\n      const x = canvasWidth - GRID.MARGIN - ((level + 1) * GRID.COLUMN_WIDTH);\r\n      \r\n      // Center siblings around parent\r\n      const siblingCount = siblings.length;\r\n      const totalHeight = siblingCount * GRID.ROW_HEIGHT;\r\n      const startY = parent.position.y + (GRID.CARD_HEIGHT / 2) - (totalHeight / 2);\r\n      \r\n      siblings.forEach((sibling, index) => {\r\n        sibling.position = {\r\n          x: Math.max(GRID.MARGIN, x),\r\n          y: Math.max(GRID.MARGIN, startY + (index * GRID.ROW_HEIGHT))\r\n        };\r\n      });\r\n    });\r\n  }\r\n  \r\n  return goals;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}