{"ast":null,"code":"export const GRID = {\n  COLUMN_WIDTH: 400,\n  ROW_HEIGHT: 140,\n  CARD_WIDTH: 320,\n  CARD_HEIGHT: 120,\n  MARGIN: 40,\n  VERTICAL_GAP: 20\n};\n\n// Convert grid coordinates to pixel position\nexport const gridToPosition = (level, row, canvasWidth) => {\n  // Right-to-left layout: level 0 (ultimate goal) is on the right, subsequent levels go left\n  const x = canvasWidth - GRID.MARGIN - (level + 1) * GRID.COLUMN_WIDTH;\n  const y = GRID.MARGIN + row * GRID.ROW_HEIGHT;\n  return {\n    x: Math.max(GRID.MARGIN, x),\n    y: Math.max(GRID.MARGIN, y)\n  };\n};\n\n// Convert pixel position to grid coordinates\nexport const positionToGrid = (position, canvasWidth) => {\n  const level = Math.max(0, Math.round((canvasWidth - position.x - GRID.CARD_WIDTH - GRID.MARGIN) / GRID.COLUMN_WIDTH));\n  const row = Math.max(0, Math.round((position.y - GRID.MARGIN) / GRID.ROW_HEIGHT));\n  return {\n    level,\n    row\n  };\n};\n\n// Get next available row for a level\nexport const getNextRowForLevel = (level, goals) => {\n  const levelGoals = goals.filter(g => g.level === level);\n  if (levelGoals.length === 0) return 0;\n  const occupiedRows = levelGoals.map(g => g.gridRow).sort((a, b) => a - b);\n  let nextRow = 0;\n  for (const row of occupiedRows) {\n    if (row === nextRow) {\n      nextRow++;\n    } else {\n      break;\n    }\n  }\n  return nextRow;\n};\n\n// Calculate position for new goal\nexport const calculateNewGoalPosition = (parentId, goals, canvasWidth) => {\n  const parent = goals.find(g => g.id === parentId);\n  if (!parent) throw new Error(\"Parent goal not found\");\n  const newLevel = parent.level + 1;\n  const newRow = getNextRowForLevel(newLevel, goals);\n  const newPosition = gridToPosition(newLevel, newRow, canvasWidth);\n  return {\n    level: newLevel,\n    row: newRow,\n    position: newPosition\n  };\n};\n\n// Calculate balanced position for child goals relative to their parent\nexport const calculateChildPosition = (parentGoal, siblingGoals, canvasWidth, canvasHeight) => {\n  const newLevel = parentGoal.level + 1;\n  const childrenCount = siblingGoals.length + 1; // +1 for the new child\n\n  // Position children to the left of parent\n  const x = canvasWidth - GRID.MARGIN - (newLevel + 1) * GRID.COLUMN_WIDTH;\n  if (childrenCount === 1) {\n    // First child: place at parent's vertical position\n    return {\n      x: Math.max(GRID.MARGIN, x),\n      y: Math.max(GRID.MARGIN, parentGoal.position.y)\n    };\n  }\n\n  // For multiple children, create a smart grid system\n  // Get all existing sibling Y positions and sort them\n  const existingYPositions = siblingGoals.map(sibling => sibling.position.y).sort((a, b) => a - b);\n\n  // Create a grid of possible positions centered around parent\n  const parentCenterY = parentGoal.position.y + GRID.CARD_HEIGHT / 2;\n  const gridSpacing = GRID.ROW_HEIGHT;\n\n  // Generate potential positions in both directions from parent\n  const potentialPositions = [];\n\n  // Start with parent's position\n  potentialPositions.push(parentGoal.position.y);\n\n  // Add positions above and below parent alternately\n  for (let i = 1; i <= childrenCount + 2; i++) {\n    const offsetAbove = parentGoal.position.y - i * gridSpacing;\n    const offsetBelow = parentGoal.position.y + i * gridSpacing;\n\n    // Add above position if within bounds\n    if (offsetAbove >= GRID.MARGIN) {\n      potentialPositions.push(offsetAbove);\n    }\n\n    // Add below position if within bounds\n    if (offsetBelow + GRID.CARD_HEIGHT <= canvasHeight - GRID.MARGIN) {\n      potentialPositions.push(offsetBelow);\n    }\n  }\n\n  // Find the first position that doesn't conflict with existing siblings\n  for (const candidateY of potentialPositions) {\n    let hasConflict = false;\n    for (const existingY of existingYPositions) {\n      // Check if cards would overlap (with safety margin)\n      const minDistance = GRID.CARD_HEIGHT + 20; // 20px safety margin\n      if (Math.abs(candidateY - existingY) < minDistance) {\n        hasConflict = true;\n        break;\n      }\n    }\n    if (!hasConflict) {\n      return {\n        x: Math.max(GRID.MARGIN, x),\n        y: Math.max(GRID.MARGIN, candidateY)\n      };\n    }\n  }\n\n  // Fallback: if no position found, place at bottom with extra spacing\n  const lastExistingY = existingYPositions[existingYPositions.length - 1] || parentGoal.position.y;\n  const fallbackY = lastExistingY + GRID.ROW_HEIGHT;\n  return {\n    x: Math.max(GRID.MARGIN, x),\n    y: Math.max(GRID.MARGIN, Math.min(fallbackY, canvasHeight - GRID.CARD_HEIGHT - GRID.MARGIN))\n  };\n};\n\n/**\r\n * Calculate standardized positions for a complete goal hierarchy\r\n * This ensures consistent positioning regardless of how goals are created\r\n * @param goals - Array of goals with hierarchy info\r\n * @param canvasWidth - Width of the canvas\r\n * @param canvasHeight - Height of the canvas\r\n * @returns Goals with standardized positions\r\n */\nexport const standardizeGoalPositions = (goals, canvasWidth, canvasHeight) => {\n  // Group goals by level\n  const levelGroups = new Map();\n  goals.forEach(goal => {\n    if (!levelGroups.has(goal.level)) {\n      levelGroups.set(goal.level, []);\n    }\n    levelGroups.get(goal.level).push(goal);\n  });\n\n  // Position level 0 (main goal) at center-right of canvas\n  const level0Goals = levelGroups.get(0) || [];\n  level0Goals.forEach((goal, index) => {\n    const centerY = canvasHeight / 2 - GRID.CARD_HEIGHT / 2;\n    const offsetY = index * GRID.ROW_HEIGHT;\n    // Use consistent positioning formula: level 0 is at (0 + 1) * COLUMN_WIDTH from the right\n    goal.position = {\n      x: canvasWidth - GRID.MARGIN - GRID.COLUMN_WIDTH,\n      y: centerY + offsetY\n    };\n  });\n\n  // Position each subsequent level relative to their parents\n  for (let level = 1; level <= 3; level++) {\n    const levelGoals = levelGroups.get(level) || [];\n\n    // Group goals by parent\n    const parentGroups = new Map();\n    levelGoals.forEach(goal => {\n      if (goal.parentId !== null) {\n        if (!parentGroups.has(goal.parentId)) {\n          parentGroups.set(goal.parentId, []);\n        }\n        parentGroups.get(goal.parentId).push(goal);\n      }\n    });\n\n    // Position each group of siblings\n    parentGroups.forEach((siblings, parentId) => {\n      const parent = goals.find(g => g.id === parentId);\n      if (!parent) return;\n      const x = canvasWidth - GRID.MARGIN - (level + 1) * GRID.COLUMN_WIDTH;\n\n      // Center siblings around parent\n      const siblingCount = siblings.length;\n      const totalHeight = siblingCount * GRID.ROW_HEIGHT;\n      const startY = parent.position.y + GRID.CARD_HEIGHT / 2 - totalHeight / 2;\n      siblings.forEach((sibling, index) => {\n        sibling.position = {\n          x: Math.max(GRID.MARGIN, x),\n          y: Math.max(GRID.MARGIN, startY + index * GRID.ROW_HEIGHT)\n        };\n      });\n    });\n  }\n  return goals;\n};","map":{"version":3,"names":["GRID","COLUMN_WIDTH","ROW_HEIGHT","CARD_WIDTH","CARD_HEIGHT","MARGIN","VERTICAL_GAP","gridToPosition","level","row","canvasWidth","x","y","Math","max","positionToGrid","position","round","getNextRowForLevel","goals","levelGoals","filter","g","length","occupiedRows","map","gridRow","sort","a","b","nextRow","calculateNewGoalPosition","parentId","parent","find","id","Error","newLevel","newRow","newPosition","calculateChildPosition","parentGoal","siblingGoals","canvasHeight","childrenCount","existingYPositions","sibling","parentCenterY","gridSpacing","potentialPositions","push","i","offsetAbove","offsetBelow","candidateY","hasConflict","existingY","minDistance","abs","lastExistingY","fallbackY","min","standardizeGoalPositions","levelGroups","Map","forEach","goal","has","set","get","level0Goals","index","centerY","offsetY","parentGroups","siblings","siblingCount","totalHeight","startY"],"sources":["C:/apps/goal-breaker/src/utils/gridHelpers.ts"],"sourcesContent":["import { Goal, Position, GridConfig } from \"../types/goal.types\";\r\n\r\nexport const GRID: GridConfig = {\r\n  COLUMN_WIDTH: 400,\r\n  ROW_HEIGHT: 140,\r\n  CARD_WIDTH: 320,\r\n  CARD_HEIGHT: 120,\r\n  MARGIN: 40,\r\n  VERTICAL_GAP: 20\r\n};\r\n\r\n// Convert grid coordinates to pixel position\r\nexport const gridToPosition = (level: number, row: number, canvasWidth: number): Position => {\r\n  // Right-to-left layout: level 0 (ultimate goal) is on the right, subsequent levels go left\r\n  const x = canvasWidth - GRID.MARGIN - ((level + 1) * GRID.COLUMN_WIDTH);\r\n  const y = GRID.MARGIN + (row * GRID.ROW_HEIGHT);\r\n  \r\n  return {\r\n    x: Math.max(GRID.MARGIN, x),\r\n    y: Math.max(GRID.MARGIN, y)\r\n  };\r\n};\r\n\r\n// Convert pixel position to grid coordinates\r\nexport const positionToGrid = (position: Position, canvasWidth: number) => {\r\n  const level = Math.max(0, Math.round((canvasWidth - position.x - GRID.CARD_WIDTH - GRID.MARGIN) / GRID.COLUMN_WIDTH));\r\n  const row = Math.max(0, Math.round((position.y - GRID.MARGIN) / GRID.ROW_HEIGHT));\r\n  \r\n  return { level, row };\r\n};\r\n\r\n// Get next available row for a level\r\nexport const getNextRowForLevel = (level: number, goals: Goal[]): number => {\r\n  const levelGoals = goals.filter(g => g.level === level);\r\n  if (levelGoals.length === 0) return 0;\r\n  \r\n  const occupiedRows = levelGoals.map(g => g.gridRow).sort((a, b) => a - b);\r\n  let nextRow = 0;\r\n  \r\n  for (const row of occupiedRows) {\r\n    if (row === nextRow) {\r\n      nextRow++;\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n  \r\n  return nextRow;\r\n};\r\n\r\n// Calculate position for new goal\r\nexport const calculateNewGoalPosition = (\r\n  parentId: number,\r\n  goals: Goal[],\r\n  canvasWidth: number\r\n): { level: number; row: number; position: Position } => {\r\n  const parent = goals.find(g => g.id === parentId);\r\n  if (!parent) throw new Error(\"Parent goal not found\");\r\n  \r\n  const newLevel = parent.level + 1;\r\n  const newRow = getNextRowForLevel(newLevel, goals);\r\n  const newPosition = gridToPosition(newLevel, newRow, canvasWidth);\r\n  \r\n  return {\r\n    level: newLevel,\r\n    row: newRow,\r\n    position: newPosition\r\n  };\r\n};\r\n\r\n// Calculate balanced position for child goals relative to their parent\r\nexport const calculateChildPosition = (\r\n  parentGoal: Goal,\r\n  siblingGoals: Goal[],\r\n  canvasWidth: number,\r\n  canvasHeight: number\r\n): Position => {\r\n  const newLevel = parentGoal.level + 1;\r\n  const childrenCount = siblingGoals.length + 1; // +1 for the new child\r\n  \r\n  // Position children to the left of parent\r\n  const x = canvasWidth - GRID.MARGIN - ((newLevel + 1) * GRID.COLUMN_WIDTH);\r\n  \r\n  if (childrenCount === 1) {\r\n    // First child: place at parent's vertical position\r\n    return {\r\n      x: Math.max(GRID.MARGIN, x),\r\n      y: Math.max(GRID.MARGIN, parentGoal.position.y)\r\n    };\r\n  }\r\n  \r\n  // For multiple children, create a smart grid system\r\n  // Get all existing sibling Y positions and sort them\r\n  const existingYPositions = siblingGoals\r\n    .map(sibling => sibling.position.y)\r\n    .sort((a, b) => a - b);\r\n  \r\n  // Create a grid of possible positions centered around parent\r\n  const parentCenterY = parentGoal.position.y + (GRID.CARD_HEIGHT / 2);\r\n  const gridSpacing = GRID.ROW_HEIGHT;\r\n  \r\n  // Generate potential positions in both directions from parent\r\n  const potentialPositions: number[] = [];\r\n  \r\n  // Start with parent's position\r\n  potentialPositions.push(parentGoal.position.y);\r\n  \r\n  // Add positions above and below parent alternately\r\n  for (let i = 1; i <= childrenCount + 2; i++) {\r\n    const offsetAbove = parentGoal.position.y - (i * gridSpacing);\r\n    const offsetBelow = parentGoal.position.y + (i * gridSpacing);\r\n    \r\n    // Add above position if within bounds\r\n    if (offsetAbove >= GRID.MARGIN) {\r\n      potentialPositions.push(offsetAbove);\r\n    }\r\n    \r\n    // Add below position if within bounds\r\n    if (offsetBelow + GRID.CARD_HEIGHT <= canvasHeight - GRID.MARGIN) {\r\n      potentialPositions.push(offsetBelow);\r\n    }\r\n  }\r\n  \r\n  // Find the first position that doesn't conflict with existing siblings\r\n  for (const candidateY of potentialPositions) {\r\n    let hasConflict = false;\r\n    \r\n    for (const existingY of existingYPositions) {\r\n      // Check if cards would overlap (with safety margin)\r\n      const minDistance = GRID.CARD_HEIGHT + 20; // 20px safety margin\r\n      if (Math.abs(candidateY - existingY) < minDistance) {\r\n        hasConflict = true;\r\n        break;\r\n      }\r\n    }\r\n    \r\n    if (!hasConflict) {\r\n      return {\r\n        x: Math.max(GRID.MARGIN, x),\r\n        y: Math.max(GRID.MARGIN, candidateY)\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Fallback: if no position found, place at bottom with extra spacing\r\n  const lastExistingY = existingYPositions[existingYPositions.length - 1] || parentGoal.position.y;\r\n  const fallbackY = lastExistingY + GRID.ROW_HEIGHT;\r\n  \r\n  return {\r\n    x: Math.max(GRID.MARGIN, x),\r\n    y: Math.max(GRID.MARGIN, Math.min(fallbackY, canvasHeight - GRID.CARD_HEIGHT - GRID.MARGIN))\r\n  };\r\n};\r\n\r\n/**\r\n * Calculate standardized positions for a complete goal hierarchy\r\n * This ensures consistent positioning regardless of how goals are created\r\n * @param goals - Array of goals with hierarchy info\r\n * @param canvasWidth - Width of the canvas\r\n * @param canvasHeight - Height of the canvas\r\n * @returns Goals with standardized positions\r\n */\r\nexport const standardizeGoalPositions = (\r\n  goals: Goal[],\r\n  canvasWidth: number,\r\n  canvasHeight: number\r\n): Goal[] => {\r\n  // Group goals by level\r\n  const levelGroups = new Map<number, Goal[]>();\r\n  goals.forEach(goal => {\r\n    if (!levelGroups.has(goal.level)) {\r\n      levelGroups.set(goal.level, []);\r\n    }\r\n    levelGroups.get(goal.level)!.push(goal);\r\n  });\r\n  \r\n  // Position level 0 (main goal) at center-right of canvas\r\n  const level0Goals = levelGroups.get(0) || [];\r\n  level0Goals.forEach((goal, index) => {\r\n    const centerY = (canvasHeight / 2) - (GRID.CARD_HEIGHT / 2);\r\n    const offsetY = index * GRID.ROW_HEIGHT;\r\n    // Use consistent positioning formula: level 0 is at (0 + 1) * COLUMN_WIDTH from the right\r\n    goal.position = {\r\n      x: canvasWidth - GRID.MARGIN - GRID.COLUMN_WIDTH,\r\n      y: centerY + offsetY\r\n    };\r\n  });\r\n  \r\n  // Position each subsequent level relative to their parents\r\n  for (let level = 1; level <= 3; level++) {\r\n    const levelGoals = levelGroups.get(level) || [];\r\n    \r\n    // Group goals by parent\r\n    const parentGroups = new Map<number, Goal[]>();\r\n    levelGoals.forEach(goal => {\r\n      if (goal.parentId !== null) {\r\n        if (!parentGroups.has(goal.parentId)) {\r\n          parentGroups.set(goal.parentId, []);\r\n        }\r\n        parentGroups.get(goal.parentId)!.push(goal);\r\n      }\r\n    });\r\n    \r\n    // Position each group of siblings\r\n    parentGroups.forEach((siblings, parentId) => {\r\n      const parent = goals.find(g => g.id === parentId);\r\n      if (!parent) return;\r\n      \r\n      const x = canvasWidth - GRID.MARGIN - ((level + 1) * GRID.COLUMN_WIDTH);\r\n      \r\n      // Center siblings around parent\r\n      const siblingCount = siblings.length;\r\n      const totalHeight = siblingCount * GRID.ROW_HEIGHT;\r\n      const startY = parent.position.y + (GRID.CARD_HEIGHT / 2) - (totalHeight / 2);\r\n      \r\n      siblings.forEach((sibling, index) => {\r\n        sibling.position = {\r\n          x: Math.max(GRID.MARGIN, x),\r\n          y: Math.max(GRID.MARGIN, startY + (index * GRID.ROW_HEIGHT))\r\n        };\r\n      });\r\n    });\r\n  }\r\n  \r\n  return goals;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}