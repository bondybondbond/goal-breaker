{"ast":null,"code":"export const GRID = {\n  COLUMN_WIDTH: 400,\n  ROW_HEIGHT: 140,\n  CARD_WIDTH: 320,\n  CARD_HEIGHT: 120,\n  MARGIN: 40\n}; // Convert grid coordinates to pixel position export const gridToPosition = (level: number, row: number, canvasWidth: number): Position => { const x = canvasWidth - GRID.MARGIN - (level * GRID.COLUMN_WIDTH) - GRID.CARD_WIDTH; const y = GRID.MARGIN + (row * GRID.ROW_HEIGHT); return { x: Math.max(GRID.MARGIN, x), y: Math.max(GRID.MARGIN, y) }; }; // Convert pixel position to grid coordinates export const positionToGrid = (position: Position, canvasWidth: number) => { const level = Math.max(0, Math.round((canvasWidth - position.x - GRID.CARD_WIDTH - GRID.MARGIN) / GRID.COLUMN_WIDTH)); const row = Math.max(0, Math.round((position.y - GRID.MARGIN) / GRID.ROW_HEIGHT)); return { level, row }; }; // Get next available row for a level export const getNextRowForLevel = (level: number, goals: Goal[]): number => { const levelGoals = goals.filter(g => g.level === level); if (levelGoals.length === 0) return 0; const occupiedRows = levelGoals.map(g => g.gridRow).sort((a, b) => a - b); let nextRow = 0; for (const row of occupiedRows) { if (row === nextRow) { nextRow++; } else { break; } } return nextRow; }; // Calculate position for new goal export const calculateNewGoalPosition = ( parentId: number, goals: Goal[], canvasWidth: number ): { level: number; row: number; position: Position } => { const parent = goals.find(g => g.id === parentId); if (!parent) throw new Error(\"Parent goal not found\"); const newLevel = parent.level + 1; const newRow = getNextRowForLevel(newLevel, goals); const newPosition = gridToPosition(newLevel, newRow, canvasWidth); return { level: newLevel, row: newRow, position: newPosition }; };","map":{"version":3,"names":["GRID","COLUMN_WIDTH","ROW_HEIGHT","CARD_WIDTH","CARD_HEIGHT","MARGIN"],"sources":["C:/apps/goal-breaker/src/utils/gridHelpers.ts"],"sourcesContent":["import { Goal, Position, GridConfig } from \"../types/goal.types\"; export const GRID: GridConfig = { COLUMN_WIDTH: 400, ROW_HEIGHT: 140, CARD_WIDTH: 320, CARD_HEIGHT: 120, MARGIN: 40 }; // Convert grid coordinates to pixel position export const gridToPosition = (level: number, row: number, canvasWidth: number): Position => { const x = canvasWidth - GRID.MARGIN - (level * GRID.COLUMN_WIDTH) - GRID.CARD_WIDTH; const y = GRID.MARGIN + (row * GRID.ROW_HEIGHT); return { x: Math.max(GRID.MARGIN, x), y: Math.max(GRID.MARGIN, y) }; }; // Convert pixel position to grid coordinates export const positionToGrid = (position: Position, canvasWidth: number) => { const level = Math.max(0, Math.round((canvasWidth - position.x - GRID.CARD_WIDTH - GRID.MARGIN) / GRID.COLUMN_WIDTH)); const row = Math.max(0, Math.round((position.y - GRID.MARGIN) / GRID.ROW_HEIGHT)); return { level, row }; }; // Get next available row for a level export const getNextRowForLevel = (level: number, goals: Goal[]): number => { const levelGoals = goals.filter(g => g.level === level); if (levelGoals.length === 0) return 0; const occupiedRows = levelGoals.map(g => g.gridRow).sort((a, b) => a - b); let nextRow = 0; for (const row of occupiedRows) { if (row === nextRow) { nextRow++; } else { break; } } return nextRow; }; // Calculate position for new goal export const calculateNewGoalPosition = ( parentId: number, goals: Goal[], canvasWidth: number ): { level: number; row: number; position: Position } => { const parent = goals.find(g => g.id === parentId); if (!parent) throw new Error(\"Parent goal not found\"); const newLevel = parent.level + 1; const newRow = getNextRowForLevel(newLevel, goals); const newPosition = gridToPosition(newLevel, newRow, canvasWidth); return { level: newLevel, row: newRow, position: newPosition }; };\r\n"],"mappings":"AAAkE,OAAO,MAAMA,IAAgB,GAAG;EAAEC,YAAY,EAAE,GAAG;EAAEC,UAAU,EAAE,GAAG;EAAEC,UAAU,EAAE,GAAG;EAAEC,WAAW,EAAE,GAAG;EAAEC,MAAM,EAAE;AAAG,CAAC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}