{"ast":null,"code":"import{standardizeGoalPositions}from'./gridHelpers';/**\r\n * Convert goals structure to Mermaid diagram format\r\n * @param mainGoal - The main goal text (can be empty if using goals array)\r\n * @param goals - Array of goal objects\r\n * @returns Mermaid diagram string\r\n */export const exportToMermaid=(mainGoal,goals)=>{if(goals.length===0)return'';const lines=['graph TD'];// Generate unique node IDs (A, B, C, etc.)\nconst getNodeId=index=>{return String.fromCharCode(65+index);// A, B, C, D...\n};// Sort goals by level and creation order for consistent output\nconst sortedGoals=[...goals].sort((a,b)=>{if(a.level!==b.level)return a.level-b.level;return a.id-b.id;});// Create mapping of goal.id to node ID\nconst goalToNodeId=new Map();sortedGoals.forEach((goal,index)=>{goalToNodeId.set(goal.id,getNodeId(index));});// Add goal nodes\nsortedGoals.forEach(goal=>{const nodeId=goalToNodeId.get(goal.id);const escapedText=goal.text.replace(/\"/g,'\\\"');// Escape quotes\nconst displayText=goal.text||(goal.level===0?'Main Goal':'Untitled Task');const finalText=goal.completed?\"\\u2705 \".concat(escapedText||displayText):escapedText||displayText;lines.push(\"    \".concat(nodeId,\"[\\\"\").concat(finalText,\"\\\"]\"));});// Add connections\nsortedGoals.forEach(goal=>{const childNodeId=goalToNodeId.get(goal.id);if(goal.parentId!==null){// Connect to parent goal\nconst parentNodeId=goalToNodeId.get(goal.parentId);if(parentNodeId){lines.push(\"    \".concat(parentNodeId,\" --> \").concat(childNodeId));}}});return lines.join('\\n');};;/**\r\n * Copy text to clipboard with fallback for older browsers\r\n * @param text - Text to copy\r\n * @returns Promise<boolean> - Success status\r\n */export const copyToClipboard=async text=>{try{if(navigator.clipboard&&window.isSecureContext){await navigator.clipboard.writeText(text);return true;}else{// Fallback for older browsers\nconst textArea=document.createElement('textarea');textArea.value=text;textArea.style.position='fixed';textArea.style.left='-999999px';textArea.style.top='-999999px';document.body.appendChild(textArea);textArea.focus();textArea.select();const result=document.execCommand('copy');document.body.removeChild(textArea);return result;}}catch(error){console.error('Failed to copy to clipboard:',error);return false;}};/**\r\n * Parse Mermaid diagram format and convert to goals structure\r\n * @param mermaidCode - The Mermaid diagram string\r\n * @returns Object with success status and either goals array or error message\r\n */export const importFromMermaid=mermaidCode=>{try{const lines=mermaidCode.trim().split('\\n');// Validate basic format\nif(lines.length===0||!lines[0].trim().startsWith('graph TD')){return{success:false,error:'Invalid format: Must start with \"graph TD\"'};}const nodes=new Map();const connections=new Map();// parent -> children\nconst nodeOrder=[];// Parse nodes and connections\nfor(let i=1;i<lines.length;i++){const line=lines[i].trim();if(!line)continue;// Parse node definitions: A[\"✅ Task text\"] or A[\"📝 Task text\"] or A[\"Task text\"]\nconst nodeMatch=line.match(/^\\s*([A-Z]+)\\[\"(.*?)\"\\]$/);if(nodeMatch){const[,nodeId,fullText]=nodeMatch;// Check if text starts with ✅ (completed)\nconst isCompleted=fullText.startsWith('✅');// Clean text: remove ✅ or 📝 emojis and trim\nlet cleanText=fullText;if(cleanText.startsWith('✅ ')){cleanText=cleanText.substring(2).trim();}else if(cleanText.startsWith('📝 ')){cleanText=cleanText.substring(2).trim();}nodes.set(nodeId,{text:cleanText.replace(/\\\\\"/g,'\"'),completed:isCompleted});nodeOrder.push(nodeId);continue;}// Parse connections: A --> B\nconst connectionMatch=line.match(/^\\s*([A-Z]+)\\s+-->\\s+([A-Z]+)$/);if(connectionMatch){const[,parent,child]=connectionMatch;if(!connections.has(parent)){connections.set(parent,[]);}connections.get(parent).push(child);continue;}}// Validate we have at least one node\nif(nodes.size===0){return{success:false,error:'No valid nodes found. Please check the format.'};}// Validate maximum depth (4 levels)\nconst validateDepth=function(nodeId){let currentDepth=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(currentDepth>3)return false;// Max 4 levels (0-3)\nconst children=connections.get(nodeId)||[];return children.every(child=>validateDepth(child,currentDepth+1));};// Find root nodes (nodes with no parent)\nconst rootNodes=nodeOrder.filter(nodeId=>!Array.from(connections.values()).some(children=>children.includes(nodeId)));// Validate depth for each root\nif(!rootNodes.every(root=>validateDepth(root))){return{success:false,error:'Maximum 4 levels supported. Please simplify your structure.'};}// Convert to Goal structure\nconst goals=[];let nextId=1;// Use viewport dimensions for proper positioning\nconst canvasWidth=window.innerWidth;const canvasHeight=window.innerHeight-80;// Account for header\n// Build level-based structure first\nconst levelNodes=new Map();// Recursive function to assign levels\nconst assignLevels=(nodeId,level)=>{if(!levelNodes.has(level)){levelNodes.set(level,[]);}levelNodes.get(level).push(nodeId);const children=connections.get(nodeId)||[];children.forEach(child=>assignLevels(child,level+1));};// Start with root nodes\nrootNodes.forEach(rootId=>assignLevels(rootId,0));// Create goals with temporary positions\nconst nodeToGoalId=new Map();for(const[level,nodeIds]of levelNodes.entries()){nodeIds.forEach((nodeId,rowIndex)=>{const nodeData=nodes.get(nodeId);if(!nodeData)return;const goalId=nextId++;nodeToGoalId.set(nodeId,goalId);// Find parent ID if this isn't a root node\nlet parentId=null;for(const[parentNodeId,children]of connections.entries()){if(children.includes(nodeId)){parentId=nodeToGoalId.get(parentNodeId)||null;break;}}const goal={id:goalId,text:nodeData.text,completed:nodeData.completed,level,gridRow:rowIndex,parentId,position:{x:0,y:0},// Temporary position\nchildren:[]};goals.push(goal);});}// Apply standardized positioning to ensure consistent layout\nconst positionedGoals=standardizeGoalPositions(goals,canvasWidth,canvasHeight);// Update children arrays\npositionedGoals.forEach(goal=>{goal.children=positionedGoals.filter(g=>g.parentId===goal.id);});return{success:true,goals:positionedGoals};}catch(error){return{success:false,error:\"Parse error: \".concat(error instanceof Error?error.message:'Unknown error')};}};","map":{"version":3,"names":["standardizeGoalPositions","exportToMermaid","mainGoal","goals","length","lines","getNodeId","index","String","fromCharCode","sortedGoals","sort","a","b","level","id","goalToNodeId","Map","forEach","goal","set","nodeId","get","escapedText","text","replace","displayText","finalText","completed","concat","push","childNodeId","parentId","parentNodeId","join","copyToClipboard","navigator","clipboard","window","isSecureContext","writeText","textArea","document","createElement","value","style","position","left","top","body","appendChild","focus","select","result","execCommand","removeChild","error","console","importFromMermaid","mermaidCode","trim","split","startsWith","success","nodes","connections","nodeOrder","i","line","nodeMatch","match","fullText","isCompleted","cleanText","substring","connectionMatch","parent","child","has","size","validateDepth","currentDepth","arguments","undefined","children","every","rootNodes","filter","Array","from","values","some","includes","root","nextId","canvasWidth","innerWidth","canvasHeight","innerHeight","levelNodes","assignLevels","rootId","nodeToGoalId","nodeIds","entries","rowIndex","nodeData","goalId","gridRow","x","y","positionedGoals","g","Error","message"],"sources":["C:/apps/goal-breaker/src/utils/mermaidHelpers.ts"],"sourcesContent":["import { Goal } from '../types/goal.types';\r\nimport { gridToPosition, calculateChildPosition, standardizeGoalPositions } from './gridHelpers';\r\n\r\n/**\r\n * Convert goals structure to Mermaid diagram format\r\n * @param mainGoal - The main goal text (can be empty if using goals array)\r\n * @param goals - Array of goal objects\r\n * @returns Mermaid diagram string\r\n */\r\nexport const exportToMermaid = (mainGoal: string, goals: Goal[]): string => {\r\n  if (goals.length === 0) return '';\r\n  \r\n  const lines: string[] = ['graph TD'];\r\n  \r\n  // Generate unique node IDs (A, B, C, etc.)\r\n  const getNodeId = (index: number): string => {\r\n    return String.fromCharCode(65 + index); // A, B, C, D...\r\n  };\r\n  \r\n  // Sort goals by level and creation order for consistent output\r\n  const sortedGoals = [...goals].sort((a, b) => {\r\n    if (a.level !== b.level) return a.level - b.level;\r\n    return a.id - b.id;\r\n  });\r\n  \r\n  // Create mapping of goal.id to node ID\r\n  const goalToNodeId = new Map<number, string>();\r\n  sortedGoals.forEach((goal, index) => {\r\n    goalToNodeId.set(goal.id, getNodeId(index));\r\n  });\r\n  \r\n  // Add goal nodes\r\n  sortedGoals.forEach((goal) => {\r\n    const nodeId = goalToNodeId.get(goal.id);\r\n    const escapedText = goal.text.replace(/\"/g, '\\\"'); // Escape quotes\r\n    const displayText = goal.text || (goal.level === 0 ? 'Main Goal' : 'Untitled Task');\r\n    const finalText = goal.completed ? `✅ ${escapedText || displayText}` : escapedText || displayText;\r\n    lines.push(`    ${nodeId}[\"${finalText}\"]`);\r\n  });\r\n  \r\n  // Add connections\r\n  sortedGoals.forEach((goal) => {\r\n    const childNodeId = goalToNodeId.get(goal.id);\r\n    \r\n    if (goal.parentId !== null) {\r\n      // Connect to parent goal\r\n      const parentNodeId = goalToNodeId.get(goal.parentId);\r\n      if (parentNodeId) {\r\n        lines.push(`    ${parentNodeId} --> ${childNodeId}`);\r\n      }\r\n    }\r\n  });\r\n  \r\n  return lines.join('\\n');\r\n};;\r\n\r\n/**\r\n * Copy text to clipboard with fallback for older browsers\r\n * @param text - Text to copy\r\n * @returns Promise<boolean> - Success status\r\n */\r\nexport const copyToClipboard = async (text: string): Promise<boolean> => {\r\n  try {\r\n    if (navigator.clipboard && window.isSecureContext) {\r\n      await navigator.clipboard.writeText(text);\r\n      return true;\r\n    } else {\r\n      // Fallback for older browsers\r\n      const textArea = document.createElement('textarea');\r\n      textArea.value = text;\r\n      textArea.style.position = 'fixed';\r\n      textArea.style.left = '-999999px';\r\n      textArea.style.top = '-999999px';\r\n      document.body.appendChild(textArea);\r\n      textArea.focus();\r\n      textArea.select();\r\n      const result = document.execCommand('copy');\r\n      document.body.removeChild(textArea);\r\n      return result;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to copy to clipboard:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Parse Mermaid diagram format and convert to goals structure\r\n * @param mermaidCode - The Mermaid diagram string\r\n * @returns Object with success status and either goals array or error message\r\n */\r\nexport const importFromMermaid = (mermaidCode: string): { \r\n  success: boolean; \r\n  goals?: Goal[]; \r\n  error?: string \r\n} => {\r\n  try {\r\n    const lines = mermaidCode.trim().split('\\n');\r\n    \r\n    // Validate basic format\r\n    if (lines.length === 0 || !lines[0].trim().startsWith('graph TD')) {\r\n      return { \r\n        success: false, \r\n        error: 'Invalid format: Must start with \"graph TD\"' \r\n      };\r\n    }\r\n\r\n    const nodes = new Map<string, { text: string; completed: boolean }>();\r\n    const connections = new Map<string, string[]>(); // parent -> children\r\n    const nodeOrder: string[] = [];\r\n\r\n    // Parse nodes and connections\r\n    for (let i = 1; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      if (!line) continue;\r\n\r\n      // Parse node definitions: A[\"✅ Task text\"] or A[\"📝 Task text\"] or A[\"Task text\"]\r\n      const nodeMatch = line.match(/^\\s*([A-Z]+)\\[\"(.*?)\"\\]$/);\r\n      if (nodeMatch) {\r\n        const [, nodeId, fullText] = nodeMatch;\r\n        \r\n        // Check if text starts with ✅ (completed)\r\n        const isCompleted = fullText.startsWith('✅');\r\n        \r\n        // Clean text: remove ✅ or 📝 emojis and trim\r\n        let cleanText = fullText;\r\n        if (cleanText.startsWith('✅ ')) {\r\n          cleanText = cleanText.substring(2).trim();\r\n        } else if (cleanText.startsWith('📝 ')) {\r\n          cleanText = cleanText.substring(2).trim();\r\n        }\r\n        \r\n        nodes.set(nodeId, { \r\n          text: cleanText.replace(/\\\\\"/g, '\"'), \r\n          completed: isCompleted \r\n        });\r\n        nodeOrder.push(nodeId);\r\n        continue;\r\n      }\r\n\r\n      // Parse connections: A --> B\r\n      const connectionMatch = line.match(/^\\s*([A-Z]+)\\s+-->\\s+([A-Z]+)$/);\r\n      if (connectionMatch) {\r\n        const [, parent, child] = connectionMatch;\r\n        if (!connections.has(parent)) {\r\n          connections.set(parent, []);\r\n        }\r\n        connections.get(parent)!.push(child);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // Validate we have at least one node\r\n    if (nodes.size === 0) {\r\n      return { \r\n        success: false, \r\n        error: 'No valid nodes found. Please check the format.' \r\n      };\r\n    }\r\n\r\n    // Validate maximum depth (4 levels)\r\n    const validateDepth = (nodeId: string, currentDepth: number = 0): boolean => {\r\n      if (currentDepth > 3) return false; // Max 4 levels (0-3)\r\n      \r\n      const children = connections.get(nodeId) || [];\r\n      return children.every(child => validateDepth(child, currentDepth + 1));\r\n    };\r\n\r\n    // Find root nodes (nodes with no parent)\r\n    const rootNodes = nodeOrder.filter(nodeId => \r\n      !Array.from(connections.values()).some(children => children.includes(nodeId))\r\n    );\r\n\r\n    // Validate depth for each root\r\n    if (!rootNodes.every(root => validateDepth(root))) {\r\n      return { \r\n        success: false, \r\n        error: 'Maximum 4 levels supported. Please simplify your structure.' \r\n      };\r\n    }\r\n\r\n    // Convert to Goal structure\r\n    const goals: Goal[] = [];\r\n    let nextId = 1;\r\n    \r\n    // Use viewport dimensions for proper positioning\r\n    const canvasWidth = window.innerWidth;\r\n    const canvasHeight = window.innerHeight - 80; // Account for header\r\n    \r\n    // Build level-based structure first\r\n    const levelNodes = new Map<number, string[]>();\r\n    \r\n    // Recursive function to assign levels\r\n    const assignLevels = (nodeId: string, level: number): void => {\r\n      if (!levelNodes.has(level)) {\r\n        levelNodes.set(level, []);\r\n      }\r\n      levelNodes.get(level)!.push(nodeId);\r\n      \r\n      const children = connections.get(nodeId) || [];\r\n      children.forEach(child => assignLevels(child, level + 1));\r\n    };\r\n    \r\n    // Start with root nodes\r\n    rootNodes.forEach(rootId => assignLevels(rootId, 0));\r\n    \r\n    // Create goals with temporary positions\r\n    const nodeToGoalId = new Map<string, number>();\r\n    \r\n    for (const [level, nodeIds] of levelNodes.entries()) {\r\n      nodeIds.forEach((nodeId, rowIndex) => {\r\n        const nodeData = nodes.get(nodeId);\r\n        if (!nodeData) return;\r\n        \r\n        const goalId = nextId++;\r\n        nodeToGoalId.set(nodeId, goalId);\r\n        \r\n        // Find parent ID if this isn't a root node\r\n        let parentId: number | null = null;\r\n        for (const [parentNodeId, children] of connections.entries()) {\r\n          if (children.includes(nodeId)) {\r\n            parentId = nodeToGoalId.get(parentNodeId) || null;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        const goal: Goal = {\r\n          id: goalId,\r\n          text: nodeData.text,\r\n          completed: nodeData.completed,\r\n          level,\r\n          gridRow: rowIndex,\r\n          parentId,\r\n          position: { x: 0, y: 0 }, // Temporary position\r\n          children: []\r\n        };\r\n        \r\n        goals.push(goal);\r\n      });\r\n    }\r\n    \r\n    // Apply standardized positioning to ensure consistent layout\r\n    const positionedGoals = standardizeGoalPositions(goals, canvasWidth, canvasHeight);\r\n\r\n    // Update children arrays\r\n    positionedGoals.forEach(goal => {\r\n      goal.children = positionedGoals.filter(g => g.parentId === goal.id);\r\n    });\r\n\r\n    return { success: true, goals: positionedGoals };\r\n\r\n  } catch (error) {\r\n    return { \r\n      success: false, \r\n      error: `Parse error: ${error instanceof Error ? error.message : 'Unknown error'}` \r\n    };\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}