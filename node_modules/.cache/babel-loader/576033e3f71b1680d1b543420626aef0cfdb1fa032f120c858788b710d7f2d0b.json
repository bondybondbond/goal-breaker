{"ast":null,"code":"import { gridToPosition } from './gridHelpers';\n\n/**\r\n * Convert goals structure to Mermaid diagram format\r\n * @param mainGoal - The main goal text (can be empty if using goals array)\r\n * @param goals - Array of goal objects\r\n * @returns Mermaid diagram string\r\n */\nexport const exportToMermaid = (mainGoal, goals) => {\n  if (goals.length === 0) return '';\n  const lines = ['graph TD'];\n\n  // Generate unique node IDs (A, B, C, etc.)\n  const getNodeId = index => {\n    return String.fromCharCode(65 + index); // A, B, C, D...\n  };\n\n  // Sort goals by level and creation order for consistent output\n  const sortedGoals = [...goals].sort((a, b) => {\n    if (a.level !== b.level) return a.level - b.level;\n    return a.id - b.id;\n  });\n\n  // Create mapping of goal.id to node ID\n  const goalToNodeId = new Map();\n  sortedGoals.forEach((goal, index) => {\n    goalToNodeId.set(goal.id, getNodeId(index));\n  });\n\n  // Add goal nodes\n  sortedGoals.forEach(goal => {\n    const nodeId = goalToNodeId.get(goal.id);\n    const escapedText = goal.text.replace(/\"/g, '\\\"'); // Escape quotes\n    const displayText = goal.text || (goal.level === 0 ? 'Main Goal' : 'Untitled Task');\n    const finalText = goal.completed ? `✅ ${escapedText || displayText}` : escapedText || displayText;\n    lines.push(`    ${nodeId}[\"${finalText}\"]`);\n  });\n\n  // Add connections\n  sortedGoals.forEach(goal => {\n    const childNodeId = goalToNodeId.get(goal.id);\n    if (goal.parentId !== null) {\n      // Connect to parent goal\n      const parentNodeId = goalToNodeId.get(goal.parentId);\n      if (parentNodeId) {\n        lines.push(`    ${parentNodeId} --> ${childNodeId}`);\n      }\n    }\n  });\n  return lines.join('\\n');\n};\n;\n\n/**\r\n * Copy text to clipboard with fallback for older browsers\r\n * @param text - Text to copy\r\n * @returns Promise<boolean> - Success status\r\n */\nexport const copyToClipboard = async text => {\n  try {\n    if (navigator.clipboard && window.isSecureContext) {\n      await navigator.clipboard.writeText(text);\n      return true;\n    } else {\n      // Fallback for older browsers\n      const textArea = document.createElement('textarea');\n      textArea.value = text;\n      textArea.style.position = 'fixed';\n      textArea.style.left = '-999999px';\n      textArea.style.top = '-999999px';\n      document.body.appendChild(textArea);\n      textArea.focus();\n      textArea.select();\n      const result = document.execCommand('copy');\n      document.body.removeChild(textArea);\n      return result;\n    }\n  } catch (error) {\n    console.error('Failed to copy to clipboard:', error);\n    return false;\n  }\n};\n\n/**\r\n * Parse Mermaid diagram format and convert to goals structure\r\n * @param mermaidCode - The Mermaid diagram string\r\n * @returns Object with success status and either goals array or error message\r\n */\nexport const importFromMermaid = mermaidCode => {\n  try {\n    const lines = mermaidCode.trim().split('\\n');\n\n    // Validate basic format\n    if (lines.length === 0 || !lines[0].trim().startsWith('graph TD')) {\n      return {\n        success: false,\n        error: 'Invalid format: Must start with \"graph TD\"'\n      };\n    }\n    const nodes = new Map();\n    const connections = new Map(); // parent -> children\n    const nodeOrder = [];\n\n    // Parse nodes and connections\n    for (let i = 1; i < lines.length; i++) {\n      const line = lines[i].trim();\n      if (!line) continue;\n\n      // Parse node definitions: A[\"✅ Task text\"] or A[\"📝 Task text\"] or A[\"Task text\"]\n      const nodeMatch = line.match(/^\\s*([A-Z]+)\\[\"(.*?)\"\\]$/);\n      if (nodeMatch) {\n        const [, nodeId, fullText] = nodeMatch;\n\n        // Check if text starts with ✅ (completed)\n        const isCompleted = fullText.startsWith('✅');\n\n        // Clean text: remove ✅ or 📝 emojis and trim\n        let cleanText = fullText;\n        if (cleanText.startsWith('✅ ')) {\n          cleanText = cleanText.substring(2).trim();\n        } else if (cleanText.startsWith('📝 ')) {\n          cleanText = cleanText.substring(2).trim();\n        }\n        nodes.set(nodeId, {\n          text: cleanText.replace(/\\\\\"/g, '\"'),\n          completed: isCompleted\n        });\n        nodeOrder.push(nodeId);\n        continue;\n      }\n\n      // Parse connections: A --> B\n      const connectionMatch = line.match(/^\\s*([A-Z]+)\\s+-->\\s+([A-Z]+)$/);\n      if (connectionMatch) {\n        const [, parent, child] = connectionMatch;\n        if (!connections.has(parent)) {\n          connections.set(parent, []);\n        }\n        connections.get(parent).push(child);\n        continue;\n      }\n    }\n\n    // Validate we have at least one node\n    if (nodes.size === 0) {\n      return {\n        success: false,\n        error: 'No valid nodes found. Please check the format.'\n      };\n    }\n\n    // Validate maximum depth (4 levels)\n    const validateDepth = (nodeId, currentDepth = 0) => {\n      if (currentDepth > 3) return false; // Max 4 levels (0-3)\n\n      const children = connections.get(nodeId) || [];\n      return children.every(child => validateDepth(child, currentDepth + 1));\n    };\n\n    // Find root nodes (nodes with no parent)\n    const rootNodes = nodeOrder.filter(nodeId => !Array.from(connections.values()).some(children => children.includes(nodeId)));\n\n    // Validate depth for each root\n    if (!rootNodes.every(root => validateDepth(root))) {\n      return {\n        success: false,\n        error: 'Maximum 4 levels supported. Please simplify your structure.'\n      };\n    }\n\n    // Convert to Goal structure using consistent grid positioning\n    const goals = [];\n    let nextId = 1;\n\n    // Use a reasonable canvas width for grid calculations\n    const canvasWidth = 1200;\n\n    // Build level-based structure first\n    const levelNodes = new Map();\n\n    // Recursive function to assign levels\n    const assignLevels = (nodeId, level) => {\n      if (!levelNodes.has(level)) {\n        levelNodes.set(level, []);\n      }\n      levelNodes.get(level).push(nodeId);\n      const children = connections.get(nodeId) || [];\n      children.forEach(child => assignLevels(child, level + 1));\n    };\n\n    // Start with root nodes\n    rootNodes.forEach(rootId => assignLevels(rootId, 0));\n\n    // Create goals level by level with consistent grid positioning\n    const nodeToGoalId = new Map();\n    for (const [level, nodeIds] of levelNodes.entries()) {\n      nodeIds.forEach((nodeId, rowIndex) => {\n        const nodeData = nodes.get(nodeId);\n        if (!nodeData) return;\n        const goalId = nextId++;\n        nodeToGoalId.set(nodeId, goalId);\n\n        // Use simple grid positioning - this ensures consistency\n        const position = gridToPosition(level, rowIndex, canvasWidth);\n\n        // Find parent ID if this isn't a root node\n        let parentId = null;\n        for (const [parentNodeId, children] of connections.entries()) {\n          if (children.includes(nodeId)) {\n            parentId = nodeToGoalId.get(parentNodeId) || null;\n            break;\n          }\n        }\n        const goal = {\n          id: goalId,\n          text: nodeData.text,\n          completed: nodeData.completed,\n          level,\n          gridRow: rowIndex,\n          parentId,\n          position,\n          children: []\n        };\n        goals.push(goal);\n      });\n    }\n\n    // Update children arrays\n    goals.forEach(goal => {\n      goal.children = goals.filter(g => g.parentId === goal.id);\n    });\n    return {\n      success: true,\n      goals\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: `Parse error: ${error instanceof Error ? error.message : 'Unknown error'}`\n    };\n  }\n};","map":{"version":3,"names":["gridToPosition","exportToMermaid","mainGoal","goals","length","lines","getNodeId","index","String","fromCharCode","sortedGoals","sort","a","b","level","id","goalToNodeId","Map","forEach","goal","set","nodeId","get","escapedText","text","replace","displayText","finalText","completed","push","childNodeId","parentId","parentNodeId","join","copyToClipboard","navigator","clipboard","window","isSecureContext","writeText","textArea","document","createElement","value","style","position","left","top","body","appendChild","focus","select","result","execCommand","removeChild","error","console","importFromMermaid","mermaidCode","trim","split","startsWith","success","nodes","connections","nodeOrder","i","line","nodeMatch","match","fullText","isCompleted","cleanText","substring","connectionMatch","parent","child","has","size","validateDepth","currentDepth","children","every","rootNodes","filter","Array","from","values","some","includes","root","nextId","canvasWidth","levelNodes","assignLevels","rootId","nodeToGoalId","nodeIds","entries","rowIndex","nodeData","goalId","gridRow","g","Error","message"],"sources":["C:/apps/goal-breaker/src/utils/mermaidHelpers.ts"],"sourcesContent":["import { Goal } from '../types/goal.types';\r\nimport { gridToPosition, calculateChildPosition } from './gridHelpers';\r\n\r\n/**\r\n * Convert goals structure to Mermaid diagram format\r\n * @param mainGoal - The main goal text (can be empty if using goals array)\r\n * @param goals - Array of goal objects\r\n * @returns Mermaid diagram string\r\n */\r\nexport const exportToMermaid = (mainGoal: string, goals: Goal[]): string => {\r\n  if (goals.length === 0) return '';\r\n  \r\n  const lines: string[] = ['graph TD'];\r\n  \r\n  // Generate unique node IDs (A, B, C, etc.)\r\n  const getNodeId = (index: number): string => {\r\n    return String.fromCharCode(65 + index); // A, B, C, D...\r\n  };\r\n  \r\n  // Sort goals by level and creation order for consistent output\r\n  const sortedGoals = [...goals].sort((a, b) => {\r\n    if (a.level !== b.level) return a.level - b.level;\r\n    return a.id - b.id;\r\n  });\r\n  \r\n  // Create mapping of goal.id to node ID\r\n  const goalToNodeId = new Map<number, string>();\r\n  sortedGoals.forEach((goal, index) => {\r\n    goalToNodeId.set(goal.id, getNodeId(index));\r\n  });\r\n  \r\n  // Add goal nodes\r\n  sortedGoals.forEach((goal) => {\r\n    const nodeId = goalToNodeId.get(goal.id);\r\n    const escapedText = goal.text.replace(/\"/g, '\\\"'); // Escape quotes\r\n    const displayText = goal.text || (goal.level === 0 ? 'Main Goal' : 'Untitled Task');\r\n    const finalText = goal.completed ? `✅ ${escapedText || displayText}` : escapedText || displayText;\r\n    lines.push(`    ${nodeId}[\"${finalText}\"]`);\r\n  });\r\n  \r\n  // Add connections\r\n  sortedGoals.forEach((goal) => {\r\n    const childNodeId = goalToNodeId.get(goal.id);\r\n    \r\n    if (goal.parentId !== null) {\r\n      // Connect to parent goal\r\n      const parentNodeId = goalToNodeId.get(goal.parentId);\r\n      if (parentNodeId) {\r\n        lines.push(`    ${parentNodeId} --> ${childNodeId}`);\r\n      }\r\n    }\r\n  });\r\n  \r\n  return lines.join('\\n');\r\n};;\r\n\r\n/**\r\n * Copy text to clipboard with fallback for older browsers\r\n * @param text - Text to copy\r\n * @returns Promise<boolean> - Success status\r\n */\r\nexport const copyToClipboard = async (text: string): Promise<boolean> => {\r\n  try {\r\n    if (navigator.clipboard && window.isSecureContext) {\r\n      await navigator.clipboard.writeText(text);\r\n      return true;\r\n    } else {\r\n      // Fallback for older browsers\r\n      const textArea = document.createElement('textarea');\r\n      textArea.value = text;\r\n      textArea.style.position = 'fixed';\r\n      textArea.style.left = '-999999px';\r\n      textArea.style.top = '-999999px';\r\n      document.body.appendChild(textArea);\r\n      textArea.focus();\r\n      textArea.select();\r\n      const result = document.execCommand('copy');\r\n      document.body.removeChild(textArea);\r\n      return result;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to copy to clipboard:', error);\r\n    return false;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Parse Mermaid diagram format and convert to goals structure\r\n * @param mermaidCode - The Mermaid diagram string\r\n * @returns Object with success status and either goals array or error message\r\n */\r\nexport const importFromMermaid = (mermaidCode: string): { \r\n  success: boolean; \r\n  goals?: Goal[]; \r\n  error?: string \r\n} => {\r\n  try {\r\n    const lines = mermaidCode.trim().split('\\n');\r\n    \r\n    // Validate basic format\r\n    if (lines.length === 0 || !lines[0].trim().startsWith('graph TD')) {\r\n      return { \r\n        success: false, \r\n        error: 'Invalid format: Must start with \"graph TD\"' \r\n      };\r\n    }\r\n\r\n    const nodes = new Map<string, { text: string; completed: boolean }>();\r\n    const connections = new Map<string, string[]>(); // parent -> children\r\n    const nodeOrder: string[] = [];\r\n\r\n    // Parse nodes and connections\r\n    for (let i = 1; i < lines.length; i++) {\r\n      const line = lines[i].trim();\r\n      if (!line) continue;\r\n\r\n      // Parse node definitions: A[\"✅ Task text\"] or A[\"📝 Task text\"] or A[\"Task text\"]\r\n      const nodeMatch = line.match(/^\\s*([A-Z]+)\\[\"(.*?)\"\\]$/);\r\n      if (nodeMatch) {\r\n        const [, nodeId, fullText] = nodeMatch;\r\n        \r\n        // Check if text starts with ✅ (completed)\r\n        const isCompleted = fullText.startsWith('✅');\r\n        \r\n        // Clean text: remove ✅ or 📝 emojis and trim\r\n        let cleanText = fullText;\r\n        if (cleanText.startsWith('✅ ')) {\r\n          cleanText = cleanText.substring(2).trim();\r\n        } else if (cleanText.startsWith('📝 ')) {\r\n          cleanText = cleanText.substring(2).trim();\r\n        }\r\n        \r\n        nodes.set(nodeId, { \r\n          text: cleanText.replace(/\\\\\"/g, '\"'), \r\n          completed: isCompleted \r\n        });\r\n        nodeOrder.push(nodeId);\r\n        continue;\r\n      }\r\n\r\n      // Parse connections: A --> B\r\n      const connectionMatch = line.match(/^\\s*([A-Z]+)\\s+-->\\s+([A-Z]+)$/);\r\n      if (connectionMatch) {\r\n        const [, parent, child] = connectionMatch;\r\n        if (!connections.has(parent)) {\r\n          connections.set(parent, []);\r\n        }\r\n        connections.get(parent)!.push(child);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // Validate we have at least one node\r\n    if (nodes.size === 0) {\r\n      return { \r\n        success: false, \r\n        error: 'No valid nodes found. Please check the format.' \r\n      };\r\n    }\r\n\r\n    // Validate maximum depth (4 levels)\r\n    const validateDepth = (nodeId: string, currentDepth: number = 0): boolean => {\r\n      if (currentDepth > 3) return false; // Max 4 levels (0-3)\r\n      \r\n      const children = connections.get(nodeId) || [];\r\n      return children.every(child => validateDepth(child, currentDepth + 1));\r\n    };\r\n\r\n    // Find root nodes (nodes with no parent)\r\n    const rootNodes = nodeOrder.filter(nodeId => \r\n      !Array.from(connections.values()).some(children => children.includes(nodeId))\r\n    );\r\n\r\n    // Validate depth for each root\r\n    if (!rootNodes.every(root => validateDepth(root))) {\r\n      return { \r\n        success: false, \r\n        error: 'Maximum 4 levels supported. Please simplify your structure.' \r\n      };\r\n    }\r\n\r\n    // Convert to Goal structure using consistent grid positioning\r\n    const goals: Goal[] = [];\r\n    let nextId = 1;\r\n    \r\n    // Use a reasonable canvas width for grid calculations\r\n    const canvasWidth = 1200;\r\n    \r\n    // Build level-based structure first\r\n    const levelNodes = new Map<number, string[]>();\r\n    \r\n    // Recursive function to assign levels\r\n    const assignLevels = (nodeId: string, level: number): void => {\r\n      if (!levelNodes.has(level)) {\r\n        levelNodes.set(level, []);\r\n      }\r\n      levelNodes.get(level)!.push(nodeId);\r\n      \r\n      const children = connections.get(nodeId) || [];\r\n      children.forEach(child => assignLevels(child, level + 1));\r\n    };\r\n    \r\n    // Start with root nodes\r\n    rootNodes.forEach(rootId => assignLevels(rootId, 0));\r\n    \r\n    // Create goals level by level with consistent grid positioning\r\n    const nodeToGoalId = new Map<string, number>();\r\n    \r\n    for (const [level, nodeIds] of levelNodes.entries()) {\r\n      nodeIds.forEach((nodeId, rowIndex) => {\r\n        const nodeData = nodes.get(nodeId);\r\n        if (!nodeData) return;\r\n        \r\n        const goalId = nextId++;\r\n        nodeToGoalId.set(nodeId, goalId);\r\n        \r\n        // Use simple grid positioning - this ensures consistency\r\n        const position = gridToPosition(level, rowIndex, canvasWidth);\r\n        \r\n        // Find parent ID if this isn't a root node\r\n        let parentId: number | null = null;\r\n        for (const [parentNodeId, children] of connections.entries()) {\r\n          if (children.includes(nodeId)) {\r\n            parentId = nodeToGoalId.get(parentNodeId) || null;\r\n            break;\r\n          }\r\n        }\r\n        \r\n        const goal: Goal = {\r\n          id: goalId,\r\n          text: nodeData.text,\r\n          completed: nodeData.completed,\r\n          level,\r\n          gridRow: rowIndex,\r\n          parentId,\r\n          position,\r\n          children: []\r\n        };\r\n        \r\n        goals.push(goal);\r\n      });\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    // Update children arrays\r\n    goals.forEach(goal => {\r\n      goal.children = goals.filter(g => g.parentId === goal.id);\r\n    });\r\n\r\n    return { success: true, goals };\r\n\r\n  } catch (error) {\r\n    return { \r\n      success: false, \r\n      error: `Parse error: ${error instanceof Error ? error.message : 'Unknown error'}` \r\n    };\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}